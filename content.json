{"posts":[{"title":"莫听穿林打叶声","text":"莫听穿林打叶声，何妨吟啸且徐行。 竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。 料峭春风吹酒醒，微冷，山头斜照却相迎。 回首向来萧瑟处，归去，也无风雨也无晴。","link":"/2017/12/18/Hello/"},{"title":"0.1 + 0.2 不等于 0.3","text":"由于精度有限，浮点数不能在计算机中精确表示，这个问题甚至有一个网站：https://0.30000000000000004.com/ 数字的二进制表示，在计算机课程中是基础，借此简单回顾总结下计算机中的数字表示，包括整数和浮点数 整数的二进制base 为k的k进制的十进制表示为： N = (an-1an-2…a1a0)k = an-1 × kn-1 + an-2 × kn-2 + … + a1 × k1 + a0 × k0 N 是一个十进制的数值且0 &lt;= ai &lt; k 11为10进制时：(11)10 = 1 x 101 + 1 x 10011为二进制时：(11)2 = 1 x 21 + 1 x 20 base在这里是一个隐含的意义，所以在计算机中经常通过增加前缀来表示这个信息： 0x11 十六进制 0o11 八进制 0b11 二进制 对一个整数可以通过取余除以base直到为0转换为k进制，比如10转化为二进制： 商 余数 10 ÷ 2 = 5 0 5 ÷ 2 = 2 1 2 ÷ 2 = 1 0 1 ÷ 2 = 0 1 从上表可以看出，每次将商用2进行除法运算，得到商和余数。高位在下，低位在上，从下往上即可得到十进制数10的二进制表示为 1010。 负整数的二进制计算机是按byte来进行寻址的，一个字节是8bit，int8, int16, int32, int64等它们都是2的n次方 这里以int8为例，上边已经求出了+10的二进制为 1010，在int8中为： 0000 1010 那负数呢，需要抽出一位来表示正负，也就是最高位，并且0为正，1为负，所以-10表示为： 1000 1010 这就是负数的原码，但是计算机并没有直接存储原码，如果尝试在c++中通过如下代码打印： 123//__int8 在windows中定义为char__int8 b = 0b10001010;printf(&quot;%d&quot;, b); //-118 得到的并不是-10 为什么符号位1表示负，而不是0表示负？ 原码、反码、补码 注意：原码、反码、补码的概念只对负数有实际意义，对于正数，原码、反码、补码都是一样的不会有下边的操作，但也可以理解为，计算机中只有补码，只是正数的补码是它自身 负数在计算机中使用补码表示，要求补码，先了解下反码。反码被定义为原码除符号位外其它按位取反 补码求值方法为反码+1（注意这不是补码的定义），-10的补码为： 对于-10：原码: 1000 1010反码: 1111 0101补码: 1111 0110 通过代码，这次打印出了-10 12__int8 b = 0b11110110;printf(&quot;%d&quot;, b); //-10 对一个负数，如果得到它的二进制原码，可以通过如下方式快速求得补码（-0不适用，因为-0取反+1有溢出）： 从右到左（低位到高）遇到第一个1不变，把1之后除符号位外的数字全部取反 如果是正数的原码，求对应负数的补码，把负号位一起取反 而补码得到原码的话也是一模一样（-$2^n$不适用，它没有原码）： 从右到左（低位到高）遇到第一个1不变，把1之后除符号位外的数字全部取反 所以对于__int8 b = 0b10001010; 它是补码的话，可以得到其原码为： 11110110，即 -(2^6 + 2^5 + 2^4 + 2^2 + 2^1) = -(64 + 32 + 16 + 4 + 2) = -118 负数 原码 反码 补码 -10 1000 1010 1111 0101 1111 0110 -118 1111 0110 1000 1001 1000 1010 -64 1100 0000 1011 1111 1100 0000 有意思的是-64的补码和原码是一样的！ 补码的作用 统一+0、-0表示如果只用原码，+0 = 0000 0000， -0 = 1000 0000，有2种不同的表示法如果用补码表示：+0 = 0000 0000，-0 = 1111 1111 + 1 = 0000 0000 （溢出了） 减法可以表示为加法a-b = a + (-b)，但是如果用原码运算会得到如下情况，比如 1 + (-1)：0000 0001 + 1000 0001 = 1000 0010 = -2??? 思考，这于这个加法，如果用反码怎么求？ 所以对于负数，得使用专门的减法逻辑，补码解决了这个问题：0000 0001 + 1111 1111 = 0000 0000 = 0 所以这个原理是什么？补码的本质是什么？ 模和同余的思想 对于长度为n的数组，如果使下标不越界？我们会取余 i % n 使得它位于0 到 n-1之间，即1 % n == (n+1) % n，这里n称为模，表示这个数组的容量 对于时钟（12小时制），现在指针在6点，再过多久指针会停留在12点？我们可以往前拨6个小时，也可以往后拨动6个小时，即6-6 % 12 = 6+6 % 12，即往前往后的效果是一样的。时钟的0=12点，它们刚好相差一个模的大小。看上面的公式，6-6 % 12 = 6+6 % 12，6-4 % 12 = 6+8 % 12。即减去一个数，等价于加上一个数，这2个数相加可以整除模，这样就把减法转化成了加法，这样其实不需要引入负数，也不需要特别的符号位，只要在所有位上直接做加法运算，溢出的位舍去就行了。 以8bit数为例，计算12-10 = 2，计算机不能直接计算-10，从上边可以知道-10可以变成加上一个数，使得12-10和12+x同余，对于个8位的数，其模为28 = 256，x = 256 - 10 = 246，把246转化为二进制为：1111 0110，做加法舍去溢出后，结果是一样的，如下表格对比： 减法 加法 0000 1100 0000 1100 0000 1010(10) 1111 0110(246) 0000 0010 0000 0010 可以发现，1111 0110正是-10的补码。对于一个8位的数，可得：原码+反码+1 = 1111 1111 + 1 = 1 0000 0000 = 256 刚好是8位的模，补码=反码+1 最大整数和最小整数 为什么8位有符号整个的范围是-128127？而不是-127127？ limits.h中定义了整数的表示范围 123456789101112131415#define _I8_MIN (-127i8 - 1)#define _I8_MAX 127i8#define _UI8_MAX 0xffui8#define _I16_MIN (-32767i16 - 1)#define _I16_MAX 32767i16#define _UI16_MAX 0xffffui16#define _I32_MIN (-2147483647i32 - 1)#define _I32_MAX 2147483647i32#define _UI32_MAX 0xffffffffui32#define _I64_MIN (-9223372036854775807i64 - 1)#define _I64_MAX 9223372036854775807i64#define _UI64_MAX 0xffffffffffffffffui64 对于无符号数，最小为全0，最大为全1；对于有符号整个，符号位占用一位，同样以8位为例 最小值 最大值 无符号 0000 0000 1111 1111 十进制 0 255 有符号 1000 0000 0111 1111 十进制 -128 127 如果用原码表示，负数的最大值为1111 1111 = -127，-128无法表示。-127到127之间共255个数，但是模有256个数，多的这个数即-0，1000 0000，在补码里为-128，在无符号数里是128 -128 = -127 - 1即补码相加：1000 0001 + 1111 1111 = 1000 0000 大端（big endian）和小端（little endian）分为机器的大小端和网络字节顺序的大小端，原理相似 高位和低位，高地址和低地址对于一个数，权重高的为高位，权重低的为低位，如16位整数0xABCDEF，AB为高位，CD为低位；对于内存地址，地址大的是高地址，地址小的为低地址，即有ph = pl + offset。 内存地址 big endian little endian 0x0000 AB EF 0x0001 CD CD 0x0002 EF AB 如何验证机器是大端还是小端？ c++: 123int a = 1;char* p = (char*)&amp;a;printf(&quot;little? %s \\n&quot;, *p == 1 ? &quot;yes&quot; : &quot;no&quot;); python 123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.byteorder'little' 或 1234import array# 一个short型的数组a = array.array('h', [0x1])print(a.tobytes()[0] == 1 and &quot;little&quot; or &quot;big&quot;) 网络字节顺序网络字节顺序NBO（Network Byte Order）：网络字节顺序规定在传输数据时，先传输高位字节，后传输低位字节，即“大端字节序”（Big-Endian）。比如传输0xABCD，先传输AB，再传输CD。 一般intel机器都小端，发送数据时，需要将本地字节顺序转换网络字节顺序，接收时，再将网络字节顺序转换为本地字节顺序。 浮点数表示浮点数用于在计算机中表示小数，资料也非常多了，浮点数是一种科学计数法，即 N = m * basee m 称为有效数，它表示了数值的精度，1 &lt;= m &lt; base base 为进制 e 称为指数，决定了数值的大小 对于10进制数123用科学计算法可以表示为:123 = 1.23 * 102 计算机中浮点数的标准为IEEE754，是各大编程语言和硬件使用的标准 F = (-1)s m 2e s是符号位，m是尾数，e是指数位,base固定为2，所以浮点数的表示只需要约定这三位即可。符号位是固定1位 定点数在说浮点数之前，先了解一下定点数，定点数指约定小数点的位置。比如在8位里，可以约定第1位表示符号，3位表示整数，最后4位表示表示小数位。一个数可以拆分成整数+小数。 在原码表示法中将小数转为二进制使用乘base取整法，比如将0.125转为二进制: 0.001 (1x2-3) 积 整数位 0.125*2=0.25 0 0.25*2 = 0.5 0 0.5*2 = 1.0 1 一些数的原码表示： 可见，在8位定点数中，$\\pi$ = 3.14159 因为精度问题无法准确表示，只能近似表示为3.125，因为小数位无法表示所有的实数，实数是连续的，但是二进制表示不是连续的。 整数位越大，数值范围越大，但是精度越低；小数位越大，精度越高，但是范围越小。这点在浮点数也有类似的规律 每一个小数，其实都有一个等效的整数。比如1.5 等效整数为 12， 即$1.5*2^3$，3即为小数位数。在不考虑小数点位置情况下，1.100 &lt;&lt; 3 = 1100(B) = 12(D) 通过$x * 2^n$,n为小数位数，可以快速求得x的等效数 单精度浮点数单精度用32位（4字节）表示，最高位为符号位，e 为8 bits，m 为23 bits，如下： 0.15625的浮点数怎么来的？ 转化为定点二进制：0.15625 * 25 = 5.0 = 0.00101 = 1.01 x 2-3 符号位 0，e = -3, m = 1.01，因为规范化（normal number）之后，m的首位总是1，所以作为约定可以舍去，尾数其实比实际的多 1 位，也就是说单精度的尾数是 24 位。这样尾数部分是01 指数有正、有负，并没有直接用补码表示。为避免使用符号位，用移码来表示。以e=8为例，它的取值范围为0~255，IEEE 754规定，e的真实值必须再减去一个中间数，对于8位的E，这个中间数是127，x - 127 = -3, 则x=124=01111100，这个为指数部分。 对于n位的指数来说，阶码：2e-1 - 1 为0 所以整个内存表示是：0 01111100 01000000000000000000000，可以通过下边程序验证 1234567float f = 0.15625f;int d = *(int*)&amp;f;printf(&quot;d = %d\\n&quot;, d); //1042284544for (int i = sizeof(int) * 8 - 1; i &gt;= 0; i--) { printf(&quot;%d%s&quot;, d &gt;&gt; i &amp; 0x1, i == 31 || i == 31-8 ? &quot; &quot;: &quot;&quot;);} //0 01111100 01000000000000000000000 为什么不使用补码？补码有什么问题？移码通过加上一个固定的偏移，去掉符号位，相对大小不变，更利于比较大小，便于对阶，即把较小的阶对齐较大的阶，方便加法运算 -1 补码 = 1 111 1111 1 补码 = 0 000 0001 -1 &lt; 1 但是按位比较 1 111 1111 &gt; 0 000 0001，结果不对 -1 移码 = 0 111 1111 1 移码 = 1 000 0001 比较结果正确 移码快速计算：补码+2n-1，即最高符号位取反 值得注意的，浮点数阶码中使用的偏置是2n-1 - 1而不是2n-1。在8位中是127而不是128，11位的双精度浮点数中是1023而不是1024。所以有： 阶码（E）= [真值（e）]补+ 2n-1 - 1 = [真值]移 - 1 [真值（e）]补 = [阶码 + 1]移 =&gt; 真值（e）= [真值（e）]补补 想了一下阶码127问题，偏移为128时候也能表示数没有问题。但是范围和对称性和127不一样；可以结合非规格化数理解。 双精度浮点数双精度浮点数用64位（8字节）表示，最高位为符号位，e 为 11 bits，m 为 52 bits，如下： 由Fresheneesz，CC BY-SA 3.0 表示方法和逻辑一致，不再赘述 一些浮点数的问题阶码范围阶码因为要表示负数，只有7位有效位，范围是0~127，所以偏移取127，8位数范围应该在1~254范围，则阶码范围在-126~127之间阶码有二类特殊情况： 全为0，此时阶码最小 当尾数m全为0时表示0，根据符号位会有+0和-0两种表示法，但都是0。注意如果按规格化数计算 1.0 x 2-127，这个值不应该为0 当尾数m不全为0时，这时用来表示非规格化浮点数， 且规定阶码为 0 - 127 + 1 = -126，这样能与规格化浮点数连续。非规格化浮点数更靠近0且更密 当阶码全是 0，尾数部分不全为 0，尾数部分没有省略的前导 1，同时指数部分的偏移值比规范形式的偏移值小 1，即单精度是 -126，双精度是 -2046。这种形式的浮点数叫非规范化浮点数（denormal number）。 全为1，此时阶码最大，e真值为128，超出127，表示无穷 当尾数m全为0时，表示无穷，根据符号位会有+infinity和-infinity两种表示法 当尾数m不全为0时，即至少有一个1时，表示NaN 浮点数的特殊值float.h中的定义： 12345678910111213141516171819#define DBL_EPSILON 2.2204460492503131e-016 // smallest such that 1.0+DBL_EPSILON != 1.0#define DBL_MANT_DIG 53 // # of bits in mantissa#define DBL_MAX 1.7976931348623158e+308 // max value#define DBL_MAX_10_EXP 308 // max decimal exponent#define DBL_MAX_EXP 1024 // max binary exponent#define DBL_MIN 2.2250738585072014e-308 // min positive value#define DBL_MIN_10_EXP (-307) // min decimal exponent#define DBL_MIN_EXP (-1021) // min binary exponent#define DBL_TRUE_MIN 4.9406564584124654e-324 // min positive value#define FLT_EPSILON 1.192092896e-07F // smallest such that 1.0+FLT_EPSILON != 1.0#define FLT_MANT_DIG 24 // # of bits in mantissa#define FLT_MAX 3.402823466e+38F // max value#define FLT_MAX_10_EXP 38 // max decimal exponent#define FLT_MAX_EXP 128 // max binary exponent#define FLT_MIN 1.175494351e-38F // min normalized positive value#define FLT_MIN_10_EXP (-37) // min decimal exponent#define FLT_MIN_EXP (-125) // min binary exponent#define FLT_TRUE_MIN 1.401298464e-45F // min positive value 以32位为例： +0：0 00000000 0000 0000 0000 0000 0000 000-0：1 00000000 0000 0000 0000 0000 0000 000以非规格化数视角来看 0.0 x 2-126 = 0 规格化最小正数：0 00000001 0000 0000 0000 0000 0000 000 阶码为1，真值为1-127=-126，+(1.0)×2−126 = 1.1754943508222875e-38 规格化最大正数：0 11111110 1111 1111 1111 1111 1111 111 阶码为254，真值为254-127=127，+(1+x)×2127，其中$$x=2^{-1} + 2^{-2} … + 2^{-23} = \\frac {1+2+4…2^{22}}{2^{23}} = \\frac {2^{23}-1} {2^{23}} = 1-2^{-23}$$ 最终结果为：2127*(224-1)/223 = 3.4028234663852886e+38 非规格化最小数(FLT_TRUE_MIN)：0 00000000 0000 0000 0000 0000 0000 001非规格化的阶码真值为-126$2^{-126}\\times2^{-23} = 1.401298464324817e-45$，这个数比规格化的更小，更靠近0 非规格化最大值：0 00000000 1111 1111 1111 1111 1111 111 $2^{-126}\\times(1-2^{-23}) = 1.1754942106924411e-38$，与规格化的最小值保持连续！！ 非规格化浮点数都 |x| &lt;&lt;&lt; 1，更靠近0 负数将符号位取反即可，是对称的，最大负数：-1.1754943508222875e-38，最小负数：-4028234663852886e+38 为什么FLT_MIN=1.175494351e-38F，小数点后为9位？因为FLT_MANT_DIG=23+1， 224 - 1 = 16777215（10进制）,有效位最多为8位。验证 1.1754943e-38和1.1754944e-38的二进制表示和FLT_MIN是一样的 FLT_MIN这个值已经超过FLOAT的最小精度了 EPSILON EPSILON 表示浮点数可表示的大于1的最小数与1差值。对32位数来说：0 01111111 0000 0000 0000 0000 0000 001，即$2^0\\times(1+2^{-23}) = 2^{-23} = 1.1920928955078125e-7$ 符点数在实数轴上并不是均匀分布的，越靠近0越密，越往Infinity越稀，比如 0 11111110 11111111111111111111111 - 0 11111110 11111111111111111111110 = 2.028240960365167e+31！ 3.4028234663852886e+38 - 1 === 3.4028234663852886e+38 思考：64位浮点数的范围和精度是多少？ 浮点数有小端、大端区分吗这个问题可转化为，在计算机内存中，低地址先存放的是尾数部分，还是符号和指数部分？显然还是需要区分的，前面打印0.15625的二进制表示，过程是从最高位到最低打印，得到：0 01111100 01000000000000000000000。可知高地址存的是符号和指数，低地址存的是尾数。 1234567891011 //在小端机器上，按内存地址从低到高打印浮点数float v = 0.15625f;__int8* pv = reinterpret_cast&lt;__int8*&gt;(&amp; v); //00000000000000000010000000111110for (int i = 0; i &lt; sizeof(v); ++i) { std::cout &lt;&lt; std::bitset&lt;8&gt;(*(pv+i)); } //将00111110 00100000 00000000 00000000按8位一组反过来将得到： //00000000 00000000 00100000 00111110 //低地址先存的尾数位 网络传输时，可以把浮点数当成一个等效的整数（即内存表示一样的整数）进行大小端转换。 0.1 + 0.2 = 0.30000000000000004总结原因有2点： 0.1和0.2 在二进制中无法精确表示，尾数部分会在0011上循环0.1:0 01111011 10011001100110011001101:0.100000001490116119384765620.2:0 01111100 10011001100110011001101:0.20000000298023223876953125和为0.30000000447034836 符点数加法对进行对阶操作，会使尾数右移。进一步损失精度 12printf(&quot;0.1 + 0.2= %.17lf\\n&quot;, 0.1 + 0.2); //0.30000000000000004printf(&quot;0.1 + 0.2= %.17lf\\n&quot;, 0.1f + 0.2f); //0.30000001192092896 注意这里不同精度下计算结果不一样，且与直接用十进制值验证的结果也不一样。说明运算过程中是有精度损失的。0.30000000000000004这个是在双精度浮点数中相加才会出现的结果。 0.1+0.2双精度浮点数相加动手验证一下0.1:0 01111111011 1.10011001100110011001100110011001100110011001100110100.2:0 01111111100 1.1001100110011001100110011001100110011001100110011010 0.1 指数为1019，0.2为1020，需要对阶，0.1指数变为1020，尾数右移一位：0.1:0 01111111100 0.11001100110011001100110011001100110011001100110011010.2:0 01111111100 1.1001100110011001100110011001100110011001100110011010 0.3:0 01111111100 10.0110011001100110011001100110011001100110011001100111 10.0110011001100110011001100110011001100110011001100111 * 21020-1023 = 0b100110011001100110011001100110011001100110011001100111 * 2-3-52 12&gt;&gt;&gt; 0b100110011001100110011001100110011001100110011001100111 * 2 **(-3-52)0.30000000000000004 [IEEE 754] https://babbage.cs.qc.cuny.edu/IEEE-754.old/IEEE-754references.html[wiki] https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E6%95%B0baseconvert","link":"/2023/02/18/bin_in_computer/"},{"title":"图形学和Shader简单介绍","text":"一次组内分享 先看一张图 如果这是一张用软件建模渲染的图，有人会说没什么稀奇。但其实这是一位叫iq大佬用各种数学公式通过Shader绘制的，是不是觉得不明觉厉。 Inigo Quilez，是一位用使用代码、数学、艺术进行shader编程，创建精美图像的大佬，同时也是一位滑雪高手。他说：你可以在电脑绘图方面打败我，但在滑雪方面不行。 图形学被称为计算机的三大浪漫之一 1. 基础1.1 什么是Shader着色器（Shader）是运行在GPU上的小程序，是一种在GPU上的编程方式。原本用于图像浓淡处理，现在广泛应用在电影后期处理、计算机成像、电子游戏等领域，着色器常被用来制作各种特效。除了普通的光照模型，着色器还可以调整图像的色相、饱和度、亮度、对比度，生成模糊、高光、有体积光源、失焦、卡通渲染、色调分离、畸变、凹凸贴图、色键（即所谓的蓝幕、绿幕抠像效果）、边缘检测等效果。 因为有CUDA和ROCm架构的存在，除了Shader，还可以使用C/C++来针对GPU编程实现大规模并行计算。比如深度学习和挖矿。 1.2 渲染管线（流水线）因为Shader是工作在渲染流水线的各个阶段，所以要了解Shader, 几乎没有不提渲染流水线。 什么是流水线？流水线解决什么问题？ 这是一个工厂生产的例子 可见流水线提提高单位时间的产量，如果把显卡比作一个工厂，比如显卡RX5802048SP, 他有2048个流处理单元，像工厂里的2048条生产线同时开工，显著提高图形的处理能力。 完整的渲染流水线是由CPU + GPU合作完成的，《Real-Time Rendering》一书中将渲染流程分为三个阶段：应用阶段(Application)、几何阶段(Geometry)、光栅化阶段(Rasterizer Stage) 应用阶段a. 准备渲染数据，加载到显存b. 设置渲染状态（如顶点属性，纹理，Shader等)c. 调用Draw call CPU 和 GPU怎么协同工作？ 几何阶段将渲染图元进行逐顶点，逐片元操作，把顶点坐标变换到屏幕空间，再交给光栅器处理 光栅化阶段得到片元，计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色，并决定哪些像素需要显示到屏幕上 注意这些只是概念上的流水线，是功能上的划分。一般我们说的GPU流水线包含几何阶段和光栅化阶段，即各个图形平台广泛应用的光栅化渲染流水线（Rasterization-Based Rendering Pipeline), Shader正是工作在这一流水线上。 1.2 渲染管线各阶段描述 顶点着色器 a. 坐标变换，把顶点坐标从模型空间变化到齐次裁剪空间 b. 逐顶点光照这个阶段并不知道顶点间的关系也不知道顶点是否处于同一个三角形，因此可以并形化处理 曲面细分着色器 (Tessellation Shader)：使用合适的细分算法，生成更高精度网格，从而提高画面的细节。 几何着色器（Geometry Shader): 几何着色器接收片元（逐片元）的一组顶点，然后可以对其进行变换，控制生成和销毁图元。这两类着色器非常强大，但是也有它的局限 opengl 3.1+, shader model 4.0; directx 10+ 不能很好并行处理 几何着色器可以用于细分吗？ 裁剪将在NDC坐标下（硬件做透视除法得到）的图元根据是否完全在视野内，部分在视野内，完成在视野外进行裁剪 屏幕映射（Screen Mapping)将三维坐标映射到屏幕上，即屏幕坐标。 三维坐标中的Z在屏幕坐标系里会怎么样？ 窗口坐标中的值会被传递到下一阶段，即光栅化 三角形设置从三角形顶点数据计算三角形网络表示数据的过程，该过程在专门为其设计的硬件上执行，得到的数据是下一阶段的输入。 三角形遍历如果一个像素被一个三角形网格所覆盖，就生成一个片元。这个过程就叫Triangle Traversal。显然片元已经和设备相关了。注意一个片元并不是一个像素，它是一个状态的集合，如屏幕坐标，深度，法线，纹理。最终是否要显示到屏幕上，显示什么颜色，还需要最后阶段的逐片元操作（Per-Frragment Operations） 片元着色器这里也是一个完全可编程的阶段，片元着色器执行逐像素的着色计算，将前面插值获得的着色数据作为输入。然后将一种或者多种颜色输出给下一个阶段。这里最典型的，最重要的技术之一就是纹理贴图（Texturing）。 逐片元操作在DirectX中叫融合（Output-Merging)， 合并阶段不是可编程的，但是是高度可配置的。这里作用是：a. 决定片元可见性b. 和颜色缓冲区中颜色混合这里有许多缓冲区完成不同的功能，如stencil缓冲区，z缓冲区，alpha缓冲区(deprecated), color缓冲区， frame缓冲区… 下图是一个颜色缓冲区（帧缓冲）的逻辑： 最后会根据混合操作的配置来更新目标颜色：C_result=C_source∗F_source+C_destination∗F_destination f source f destination SrcAlpha OneMinusSrcAlpha 正常 OneMinusDstAlpha One 柔和相加（Soft Addtive) DstColor Zero 正片叠底（Multiply），即相乘 DstColor SrcColor 两倍相乘（2x Multiply） 1.3 图形学中的数学 笛卡尔坐标、点、向量 坐标系分左手和右手 点积的几何意义之一，就是可以表示投影，这在光照计算中很有用 叉积结果是一个向量，可以用来计算一个平面，三角形矢量，判断面的朝向 矩阵 向量可以看成nX1的列矩阵[x, y, z]T，或者1Xn的行矩阵[x, y, z] 矩阵的几何意义在图形中是变换（transform） 线性变换 12f(x) + f(y) = f(x+y)kf(x) = f(kx) 线性变换有：旋转、缩放、镜像、正交投影、错切，线性变换可以用M33矩阵表示出来但是平移不是线线的，于是引入了仿射变换（affine transform），合并了线性变换和平移，并引入了齐次坐标空间，把3x3矩阵扩展到了4x4。 齐次坐标变为了[x,y,z,w] 坐标空间变换也用矩阵来表示 局部空间(Local Space，或者称为物体空间(Object Space))世界空间(World Space)观察空间(View Space，或者称为视觉空间(Eye Space))裁剪空间(Clip Space)屏幕空间(Screen Space) 2. Shader 编程2.1 Shader编程语言可编程渲染管线出现之前，Shader是用汇编语言来实现的。随着发展，出现了更高级的Shading Language。 GLSL: OpenGL, 由于opengl是良好的跨平台性, GLSL也有良好的跨平台性，但是这个跨平台性是由各个硬件产商自己实现的。 HLSL: DirectX, 基本只用于微软自己的产品。 cg(C for Graphic), Nvidia设计的真正跨平台的GPU编程语言，它会根据平台的不同，编译成相应的中间语言（计算机中没有增加中间层解决不了的问题T_T）。由于nvidia和microsoft的合作，他们在标准硬件光照语言的语法和语义上达成了一致，因此Cg和HLSL（DX9+)很像。比如在Unity上，我们一般说使用Cg/HLSL或者GLSL编写Shader。因为CG不再被维护，Unity也使用HLSL编译器来编译 2.2 cg/hlsl介绍2.2.1 语法HLSLCG 列举一些与c不同的地方： 关键字 uniform 修饰顶层变量，提供了一种和外部语言沟通的机制 1uniform float4 position in/out/inout 定义函数参数，指定它是输入输出参数 … 变量 half 16位浮点数 fixed [-2, 2] 之间的浮点数 向量和矩阵 向量 type, 如： 12345int1 iVector = 1;float3 v = float3(0.2, 0.3, 0.4);float3 v = {0.2, 0.3, 0.4};float3x3 m = float3x3(1, 2, 3, 4, 5, 6, 7, 8, 9)float3x3 m = float3x3(v, v, v); swizzle 12float3 v = float3(0.2, 0.3, 0.4);float4 a = v.xxyz; 矩阵也可以swizzle 1234float4x4 myMatrix;float myFloatScalar;// Set myFloatScalar to myMatrix[3][2]myFloatScalar = myMatrix._m32; 语义（Semantics）可以用在函数参数，返回值，结构体内。语义定义了shader在流水线不同阶段解释（读写）数据的方式，有些语义只能用于顶点着色器，有些只能用于片元着色器，有些在两个地方都能用： POSITION 物体空间的顶点坐标，作为顶点着色器的输入 SV_Target Render target, 有多个，渲染的最终位置 COLOR 一般用来传递漫反射或高光颜色 2.2.2 常用函数 clamp/saturate 截取clamp(x, min, max)将x截断到[min, max]内clamp(1, 2, 3) //2 fmod(x, y) 浮点数取余 12345a = 9.2;b = 3.7;c = 2;fmod(a,c); //1.2fmod(b,c); //1.8 常用于限制范围，产生循环 smoothstep 平滑阶梯函数 将x映射到[0,1]并且做一个平滑处理，t1是可以大于t2的，它决定了曲线的走向 1234float smoothstep(float t1, float t2, float x) { x = saturate((x - t1) / (t2 - t1), 0.0, 1.0); return x * x * (3 - 2 * x);} 常用于边界的平滑过度 lerp 插值, 也叫mixlerp(x, y, t) 在x, y之间进行插值，即x + (y-x)*t 1lerp(1, 2, 0.5) //1.5 lerp经常用来混合2个数据，比如颜色之类 2.3 Shader LabUnity中使用自己的Shader Lab来进行Shader编程。粗略地可以把Shader Lab理解成Java中的Spring或者JS里的React。它最终会被编译成目标平台的Shader。 Shader Lab有三类着色器： 表面着色器：使用CG/GLSL语法，可以看作是下面一种更高的抽象。比如可以直接使用预定义的光照模型 顶点片元着色器：使用CG/GLSL语法，最灵活的，但是自己要做的事情要多一些 固定函数着色器：为兼容最老旧的显卡而存在，一般不会用了 unity 2018还可以使用Shader Graph可视化方式帮你生成Shader，不用写代码！ 2.3.1 ShaderLab 语法一个基本的具有固定的结构 123456Shader &quot;&lt;name&gt;&quot; { &lt;optional: Material properties&gt; &lt;optional: custom editor&gt; &lt;One or more SubShader definitions&gt; &lt;optional: fallback&gt;} Shader Name是Shader标识 12Shader &quot;Examples/ShaderSyntax&quot; {} properties是材质和shader的桥梁property是对uniform变量更方便的使用 1234Properties { _VarName (&quot;display name&quot;, PropertyType) = DefaultValue ...} 颜色_Color (“Color”, Color) = (1,0,0,0) 小数_Radius(“Dot Width”, Float) = 1 SubShader是shader逻辑实现的地方 SubShader至少有一个，当unity加载Shader时，依次为目标平台选择一个可运行的SubShader，结构如下： 123456789101112SubShader { [Tags] //Tags { &quot;RenderType&quot; = &quot;Opaque&quot; } [RenderSetup] //LOD 150, Cull On Pass { [Name] //Name &quot;pass_name&quot; [Tags] ////Tags { &quot;LightMode&quot; = &quot;ForwardBase&quot; } [RenderSetup] //这里可以使用SubShader的渲染设置 CGPROGRAM //cg code ENDCG }} Fallback当没有SubShader可用时，使用Fallback ‘ShaderName’指定的Shader,也可以使用Fallback Off关闭该功能 2.3.2 ShaderLab 常用变量/函数介绍unity 内置的变量/函数可以简化计算，并且抹平不同平台的差异, 使用时候需要：#include &quot;UnityCG.cginc&quot; 只介绍下边会用到的： UNITY_MATRIX_MVP/UnityObjectToClipPos模型视图投影矩阵，将模型坐标变换到裁剪空间 ComputeScreenPos从裁剪空间计算屏幕空间的坐标注意该坐标是中心坐标用小数表示，如果视口是[0,0,480,600], 那么ScreenPos = [0.5,0.5,480.5,600.5] _ScreenParams屏幕参数, float4类型，含义如下：x 是当前渲染目标在像素值中宽度y 是当前渲染目标在像素值中的高度z 是 1.0 + 1.0/widthw 是 1.0 + 1.0/height _Timefloat4类型:x t/20y tz t2w t3t 自场景加载以来时间，一般用于Shader中产生动画 3. 实践一下如何用fragment shader画一个心形？ 3.1 绘制基础在这之前，先了解下坐标系设置。并在屏幕上绘制一个简单的圆，理解shader绘图机制，结合前面提到要点，理解工作原理 新建一个顶点片元着色器在Project View中-&gt;右键-&gt;Create-&gt;Shaer-&gt;Unlit Shader. 修改生成的代码，在顶点着色器中添加： 1234567v2f vert (float4 v : POSITION){ v2f o; o.vertex = UnityObjectToClipPos(v); o.scrPos = ComputeScreenPos(o.vertex); return o;} 注意这里使用ComputeScreenPost而不是VPOS语义，实现平台无关的坐标系，经测试VPOS在Windows下的左上角是原点 理解坐标系在片元着色器中加入如下代码： 123456fixed4 frag (v2f i) : SV_Target{ //这里是齐次坐标系，除以w将得到ndc坐标，范围在[0,1] float2 fragCoord = i.scrPos.xy / i.scrPos.w; return fixed4(fragCoord, 0, 1);} 会得到 可以看到左路下方为（0，0）， 右上角为（1，1）, 为了使用方便我们将坐标系移到屏幕中心并归一化 12float2 fragCoord = i.scrPos.xy / i.scrPos.w * _ScreenParams.xy;fragCoord = (2 * fragCoord - _ScreenParams.xy) / min(_ScreenParams.x, _ScreenParams.y); 这样坐标中心是[0,0], 当我们在[-2, 1]之间绘制时，就能保证所有东西在屏内。 3.2 心的数学 atan2(y, x)返回向量x,y的与x轴的夹角并能正确处理0值。当点(x, y) 落入第一象限时，atan2(y, x)的范围是 0 ~ pi/2;当点(x, y) 落入第二象限时，atan2(y, x)的范围是 pi/2 ~ pi;当点(x, y) 落入第三象限时，atan2(y, x)的范围是 －pi ~ －pi/2;当点(x, y) 落入第四象限时，atan2(y, x)的范围是 -pi/2～0.可见返回[-pi, pi] atan计算屏幕上任一点的与x的角，如果用极坐标方程表示,r=theta 如图所示: 问题转化为如果length(p) &lt;= theta则落在心形线内。 12345float a = atan2(p.x, p.y) / 3.1415926;float r = length(p);float d = a - r;return lerp(bcol, _Color, smoothstep(-0.01, 0.01, d)); 会得到半个心： 1a = abs(a); 得到一个完整的心，然后交换x, y轴，atan2(p.y, p.x), 将心翻转过来，并调整一下位置。 但是这个心太胖了，用下边这个函数调整一下：y = (13.0x - 22.0xx + 10.0xxx)/(6.0-5.0*x); 1234567float a = atan2(p.x, p.y) / 3.1415926;float r = length(p);a = abs(a);a = (13.0*a - 22.0*a*a + 10.0*a*a*a)/(6.0-5.0*a);float d = a - r;return lerp(bcol, _Color, smoothstep(-0.01, 0.01, d)); 3.3 让心跳动起来y=(x^0.20.5 + 0.5)-(x^0.20.5 + 0.5)0.2sin(x6.82313)e^(-x4)函数图产生一个非线性的动画变换 1234float tt = fmod(_Time.y,1.5)/1.5;float ss = pow(tt,.2)*0.5 + 0.5; ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0); p *= float2(0.5,1.5) + ss*float2(0.5,-0.5); 最后一行给x,y方向不同的跳动因子和方向","link":"/2021/05/16/cg/"},{"title":"异常中的finally","text":"异常处理中，在捕获异常后还可以再次抛出异常，也可以在catch中return，那在finally中是否还可以再次抛出异常、是否可以return，下面是测试几种常用语言的结果总结 js123456789101112131415function test_except() { try{ let a = undefined a.b() } catch { console.log('ex catched') } finally { console.log('finally') throw 'error' //会throw error, 让return 不会执行 return 1 //如果没有throw，会被执行，return 2不可达 } return 2} 可以throw，可以return且throw、return后的语句都不可达 python12345678910def test_except(): try: a = 1/0 except: print('ex catched') finally: # raise Exception('error') return 1 return 2 同js java1234567891011121314private static int test_except() throws Exception { try { float a = 1 / 0; } catch(Exception e) { System.out.println(&quot;ex catched&quot;); } finally { System.out.println(&quot;finally&quot;); throw new Exception(&quot;error&quot;); // return 1; } // return 2; //throw会让这里变成语法错误} 行为和js一致，但是在throw或者return后的不可达代码被认为是语法错误 ruby12345678910111213141516171819#!/usr/bin/ruby -wdef test_except begin a = 1 / 0 puts a rescue Exception =&gt; e puts e.message # retry else # 没有异常时候的块 puts 'else in except' ensure puts 'finally' raise 'error again' return 1 end return 2end ensure 等于 finally，行为和js一致。 c#12345678910111213141516171819public int test_except(int num) { int result = 0; try { result = 1 / num; } catch (DivideByZeroException e) { Console.WriteLine(&quot;except catched: {0}&quot;, e); } finally { Console.WriteLine(&quot;Result: {0}&quot;, result); throw new Exception(&quot;error&quot;); // return 1; //语法错误 } return 2; //throw会使return不会被执行，但不是语法错误 } finally中都可以再抛出异常，但不应当这么做，finally用于确保资源的正确释放。特别地：C# 不能从finally中return，而其它几个语言finally块中的代码和其它地方代码没什么特别，只是在有、无异常都会被调用的语法糖。注意：c++没有finally，在C++中通常使用RAII（Resource Aquisition Is Initialization）.就是将资源封装成一个类，将资源的初始化封装在构造函数里，释放封装在析构函数里。通过局部变量析构函数总是会被调用的特性实现","link":"/2022/10/01/exception-for-langs/"},{"title":"字符编码回顾","text":"记得以前十多年前上网的时候，会经常碰到网页乱码，然后就会在浏览器选择一个合适的字符编码。 编码看起来有很多，但其实是早期没有统一造成的编码是一种映射规则，字符编码作用就是将字符映射成二进制以便在计算机中存储和传输。编码总体上我把它归为三大类: 1. ASCIIascii在60年代就出现了，全称是American Standard Code for Information Interchange，它用7位表示0-127之间的128个字符。存储时是8位。重要的字符如’0’==48，A==65,a==97 2. ANSI因为ascii不够用，就出现了ansi编码American National Standards Institute，ansi并不单独指一种具体的编码，它是这个委员会注册的国际通用集，是对ascii的扩展。使用8位表示，即扩展了128-255。ansi码不同国家和地区都不相同，是不通的，这也是以前网页乱码的原因。通常说ansi码是指本机本系统使用的编码，常见的ansi: latin-1 (ISO-8859-1) 兼容ascii，编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。它用完了单个字节的所有空间。 gb2312 gb2312 是简体中文的编码，兼容ascii，为什么说它是ascii扩展码？如同拉丁编码一样，使用&gt;=0xA0表示字符，但是每个字符固定用2个字节表示。EUC-CN表示法中：每个字符被分了区，比如啊字在16区1位，那么第一字节为0xA0+16 = 0xB0第二字节为0xA0+1 = 0xA1合起来0xB0A1表示啊字 所以它是在ascii上作了扩展，使用0xA0后的空间，解码时候是每2字节解码。 GBK 向下与 gb2312 编码兼容，是gb2312的扩充，包含了古文、繁体等等 UNICODEunicode不是一种编码方式，是一个世界通用的字符集。定义了世界上每一个字符对应的码点值，最大为0x10FFFF，显然也超过2个字节了。unicode的编码方式最常见的就是utf-8了。 utf-8UTF-8编码是Unicode的实现方式，是一种具体的编码方法，如同gbk一样。UTF-8（8-bit Unicode Transformation Format），是可变长度的，使用1-4个字节表示一个字符。utf-8编码规则： Unicode范围 UTF-8编码方式 字节数 0000 0000-0000 007F 0xxxxxxx 1 0000 0080-0000 07FF 110xxxxx 10xxxxxx 2 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 3 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 4 0开头，表示是单字节，110开头，2个1表示2个字节，1110开头，表示3个字节，11110开头，表示4个字节，对于多字节的都是10开头，这些称为控制字符 4字节*8=32位，减去11位控制位 = 21位数字位即1 1111 1111 1111 1111 1111 = 0x1FFFFF 可表示的字符是可以覆盖到unicode所有的字符的 “啊”字unicode U+554A &gt; 0800需要三个字节，二进制为：0101 010101 001010，将其放入xxxx位，即:11100101 10010101 10001010 即 0xE5 95 8A utf-16值得注意的是utf-16也是可变长编码，并不是固定的2个字节（要表示完所有的unicode，2个字节是不够的，65536 远小于 1,112,064），而utf-32（ucs-4）可以和unicode一一映射，固定4个长度。utf-16和utf-32都需要bom信息。 BOMBOM 即byte order mark，是在文件头用来标识编码的字节顺序。字节顺序是内存中读取一段字节的约定，即高位是放在内存的高位地址（big-endian）还是低位地址（little-endian），bom现在还标识了编码，当有bom时候，程序根据bom去解码文件。 锟斤拷和烫烫烫当有字符不能映射到unicode字符集时，unicode会用U+FFFD表示，称为REPLACEMENT CHARACTER，如果用utf8编码即为\\xef\\xbf\\xbd，重复一次总共6个字节，用gbk编码表示，每两个字节一个汉字，\\xef\\xbf\\xbd\\xef\\xbf\\xbd：\\xef\\xbf = 锟\\xbd\\xef = 斤\\xbf\\xbd = 拷 123456789# unicode 最大字符序列为0x10FFFF# u=chr(0x0010FFFF+1) # ValueError: chr() arg not in range(0x110000)# print(u) a = b'\\x80\\x90'# 文件中存在这样的字符，unicode无法表示b = a.decode(&quot;utf-8&quot;, &quot;replace&quot;) # u+FFFD 替换c = b.encode() #b'\\xef\\xbf\\xbd\\xef\\xbf\\xbd'print(c)d = c.decode(&quot;gbk&quot;)print(d) # 锟斤拷 vc 未初始化的内存用0xcc填充，值得注意的是0xcc是int3中断指令；堆上的未初始化内存用0xcd填充，同样地，可以模拟一下： 123456s = b'\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc' # 未初始化的内存sd = s.decode(&quot;gbk&quot;) # 使用gbk显示内存中的内容print(sd) # 烫烫烫h = b'\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd'hd = h.decode(&quot;gbk&quot;)print(hd) # 屯屯屯","link":"/2022/12/28/char-encode/"},{"title":"FDTD(Finite-Difference Time-Domain)","text":"基础概念电场每个原子里面都有绕原子核心运动的电子(经典力学上是这么说)，原子核中有质子。电子带负电，质子带正电。当正负相中和，物体对外表现中性。否则表现为带电。宏观上，带电体之间会相互作用，同极相斥，异极相吸。这种相互作用力叫做电场力。带电体不管静止和运动，都会产生电场。静止的称为静电场，运动的称为感应电场。电场会使其中的电荷受力，可使其运动。因此电场具有势能，就像重力会产生重力势能一样。电场中两点间电势的差值叫做电势差（电压） 电场强度为E = F/q。单位为牛顿每库伦，符号为N/C。其中q是试探电荷量，F是电荷在电中受到的力。另一单位是伏特每米，符号为V/m。E=U/d，其中U是电压，d是电场中两点的距离。他们是等效的: ‌从电场力的公式出发‌，F = Eq，将E的单位N/C代入，得到F的单位是N。‌&gt; 从电势差的公式出发‌，U = Ed，将E的单位V/m代入，得到U的单位是V。由于电势差U和距离d的单位分别是伏特和米，而1伏特等于1焦耳每库仑（J/C），因此1V/m = 1J/(C·m) = 1(N·m)/(C·m) = 1N/C‌。1 焦耳 是1牛的力作用于1米的距离电荷量的单位是库仑（coulomb）C。1C的电荷量相当于6.25×1018个电子所带的电荷量，一个普通大小的物体很难保持多于千分之一库仑的净电荷。 电场会随距离而减弱 E=kQ / r^2 空间的电场强度是矢量，方向是电场力作用的方向。 线性运动的电荷不会产生变化的电场 空间任一点的电场强度是该点多个电荷所产生的电场强度的矢量和。 电场虽然看不见，摸不着，但是一种物质, 具有能量和动量。就像扔的一块石头一样。唯一不同的是，这种物质没有静止的质量 这种电子的定向运动就产生了电流。物体内部分子的排列杂乱无章，使这些“分子电流”在物体内部互相抵消，总体没有环形电流，但一旦物体被磁化，分子就被有序排列，总体就产生了环形电流，也就有了磁性。 磁场磁场现象的发现更早。在战国时期，我国就发明了指南针。与电场相仿，磁场是在一定空间区域内连续分布的向量场，描述磁场的基本物理量是磁感应强度矢量B，也可以用磁感线形象地表示。西莫恩·泊松发展出一种物理模型，比较能够描述磁场。泊松认为磁性是由磁荷产生的，同类磁荷相排斥，异类磁荷相吸引。他的模型完全类比现代静电模型；磁荷产生磁场，就如同电荷产生电场一般 然而，作为一个矢量场，磁场的性质（宏观）与电场颇为不同。 磁场是无源有旋的矢量场，磁力线是闭合的曲线簇，不中断，不交叉。从N出发，指向S 磁场的运动相对性是指与场源同速运动的观察者及其检测仪器都不能测到运动中的场源所产生的磁场，而与场源不同速时则可测到场源的磁场。例如在地球表面参考系中，我们测定静止于地球表面的电子不产生磁场，但是这个静止于地球表面的电子却在不停地随同地表进行自转并围绕太阳公转。又例如，使导线对外产生磁场的电流是大量电子定向运动的结果。该载流导线在对外产生磁场的同时，其中的每一个运动电子并不被与其同行的其它电子的磁场所干扰，因为所有同行的电子都具有同等磁化而无法感受到其它电子磁场的存在 磁极不能单独存在，无论把磁铁切多么小，都会出现新的磁极 磁场分为静磁场和动磁场。地球的磁场属于静磁场，电磁铁的磁场属于动磁场。 磁场性质 磁感应强度：与磁力线方向垂直的单位面积上所通过的磁力线数目，叫磁通密度，用B表示，单位为特斯拉（T）。 磁通量：磁通量是通过某一截面积的磁力线总数，用Φ表示，单位为韦伯（Weber），符号是Wb。 通过一线圈的磁通的表达式为：Φ=B·S（其中B为磁感应强度，S为该线圈的面积。） 1Wb=1T·m2 磁场强度：单位正电磁荷在磁场中所受的力被称为磁场强度(符号为H A/m)，类比电荷。安培分子流假说认为并不存在磁荷，自此磁场的强度多用磁感应强度(符号为B)表示。 但是在磁介质的磁化问题中，磁场强度作为一个导出的辅助量仍然发挥着重要作用。介质中，$H := \\frac{B}{\\mu_0} - M$ 安培力：匀强磁场对通电直导线的作用力，即安培力与磁感应强度、电流和导线长度成正比。（左手定则）F=BILsinθ 矢量表达式：F=I×BL。 洛伦兹力：磁场会对电荷施加力。运动电荷在磁场中所受到的力以荷兰物理学家洛伦兹（H. A. Lorentz， 1853—1928）的姓氏命名，称为洛伦兹力（Lorentz force）。 （左手定则）F=qvBsinθ。矢量表达式：F=qv×B 与电场的关系在很长一段时间里，人们把磁现象和电现象看成两种彼此独立的自然现象。直到1820年丹麦物理学家奥斯特（H．C．Oersted，1777-1851）发现了电流的磁效应之后，人们才逐渐认识到电和磁之间的内在联系。 经典物理学发现，变化的磁场产生电场，变化的电场产生磁场。这些实际是假设，这个假设基于电磁感应现象。 后来，麦克斯韦将各种电、磁方程整合，发展出麦克斯韦方程组，这方程组能够解释经典电学和磁学的各种现象。他提出了“分子涡流模型”，并成功地将安培定律加以延伸，增加入了一个有关于位移电流的项目，称为“麦克斯韦修正项目”。可以描述电磁波的行为，推导出电磁波方程。他又计算出电磁波的传播速度，发现这数值与光速非常接近。警觉的麦克斯韦立刻断定光波就是一种电磁波。后来，于1887年，海因里希·鲁道夫·赫兹做实验证明了这事实。麦克斯韦统一了电学、磁学、光学理论。 爱因斯坦在发展出狭义相对论的思想实验里，表明电场和磁场是处于不同参考系的观察者所观察到的同样现象。电场和磁场是电磁场的两面。设定两个参考系A和B，相对于参考系A，参考系B以有限速度移动。从参考系A观察为静止电荷产生的纯电场，在参考系B观察则成为移动中的电荷所产生的电场和磁场。 变化的电场产生磁场，那么磁铁是怎么形成的呢？磁铁上有电流吗？ 磁铁对外没有电流，但是内部有电流，这就是安培分子流假说：在原子、分子等物质微粒内部，存在着一种环形电流——分子电流，分子电流使每个物质微粒都成为微小的磁体，它的两侧相当于两个磁极。一根铁棒，未被磁化的时候，内部各分子电流的取向是杂乱无章的，它们的磁场互相抵消，对外界不显磁性。当铁棒受到外界磁场的作用时，各分子电流的取向变得大致相同，铁棒被磁化，两端对外界显示出较强的磁作用，形成磁极。 现代物理学否定了原先流行的磁荷观。不过英国物理学家保罗·迪拉克在1931年利用数学公式预言了磁单极粒子的存在。当时他认为既然带有基本电荷的电子在宇宙中存在，那么理应带有基本“磁荷”的粒子存在。科学家仍没有放弃寻找磁单极粒子。如果找到了，电磁理论将要作重大修改。 磁铁能否永久保持其强度？磁铁一直对外做功，磁性会减弱甚至消失吗？ 只要使磁铁远离对其磁性产生负面影响的因素（例如电源线、其他磁铁、高温等），理论上它将永久保持其磁性。比如强磁质的特殊性质在高温下会失效，使得强磁质性质失效的临界温度叫做居里点。 这被解释为高温使得分子运动剧烈，磁铁内部的分子电流方向变得杂乱无章，磁场互相抵消，磁性消失。 当使用磁铁吸附物体或推开物体，是外部力量与磁场的能量相互转化，是能量从一种形式转化到另一种形式，只要磁铁内部排列不变，磁铁的磁性就不会减弱。 电磁波简介机械波在了解到电磁波前，自然界中还存在机械波。在机械波中，振动的传播需要具有弹性的介质。机械波分为横波和纵波。横波是振动方向垂直于波的传播方向，纵波是振动方向与波的传播方向一致。声波是一种纵波，水波是近似横波。地震波是一种复合波。描述波的物理量：波长λ、波速v、频率f频率：波的频率就是波源的振动频率，也是所有质点的振动频率。是单位时间内完成周期振动的次数波速：波在均匀介质中匀速传播的速率只与介质有关，而与频率无关。波长：在波动中振动相位总是相同的两个相邻质点间的距离。对于横波，相邻的两个波峰或相邻的两个波谷之间的距离等于一个波长。 它们三者的关系是：v=λf 波具有干涉、衍射、偏振、折射、反射等现象。同时波还能传播能量。 电磁波电磁波又叫电磁辐射，是指同相振荡且互相垂直的电场与磁场，是一种非机械波，在空间中以波的形式传递能量和动量，其传播方向垂直于电场与磁场的振荡方向是一种横波，和机械波一样，符合波理论。和机械波不同的是，它的传播不需要介质，在真空中也能传播。现代量子场论中光子被认为是电磁相互作用的媒介子。 光子静止质量为零。光子以光速运动，并具有能量、动量、质量。光具有波粒二象性 电磁波的波长和频率有关系：c=λf，其中c是光速，约等于3×10^8m/s。电磁辐射由低频率到高频率主要分为：无线电波、微波、红外线、可见光、紫外线、X射线和γ射线。人眼可接收到的电磁波，称为可见光（波长380~780nm） 在电动力学里，根据麦克斯韦方程组，随着时间变化的电场产生了磁场，反之亦然。因此，一个振荡中的电场会产生振荡的磁场，而一个振荡中的磁场又会产生振荡的电场，这样子，这些连续不断同相振荡的电场和磁场共同地形成了电磁波。电场，磁场都遵守叠加原理。因为电场和磁场都是矢量场，所有的电场矢量和磁场矢量都适合做矢量加运算。例如，一个行进电磁波，入射于一个介质，会引起介质内的电子振荡，因而使得它们自己也发射电磁波，因而造成折射或衍射等等现象。电碰波的能量一半存于电场，一半存于磁场。比如我们可以使用电场天线和磁场天线来“感知”电磁波中的电场和磁场 麦克斯韦方程组麦克斯韦方程组有微分和积分表示，但等价。并且真空和介质略有不同，积分形式更容易理解一些，下边以真空中的麦克斯韦方程来了解。 高斯定律, 描述通过任意闭曲面的电通量与这闭曲面内的电荷之间的关系。 $$ \\displaystyle \\oiint _\\mathbb{S} \\mathbf {E} \\cdot \\mathrm {d} \\mathbf {s} ={\\frac {Q}{\\varepsilon _{0}}}$$ Q: 闭曲面内的总电荷 $\\epsilon_0$是真空介电常数 E: 电场强度 可见电通量只与电荷有关，电场是有源场 高斯磁场定律, 描述通过任意闭曲面的磁通量等于零。 $$\\displaystyle \\oiint _\\mathbb{S} \\mathbf {B} \\cdot \\mathrm {d} \\mathbf {s} =0$$ B: 磁感应强度 表明通过任意闭曲面的磁通量等于零，磁场是无源场，不存在单极子 法拉第电磁感应定律：时变磁场产生感应电场。 $$\\displaystyle \\oint _{\\mathbb{L}} \\mathbf {E} \\cdot \\mathrm {d} \\mathbf {l} =-{\\frac {\\mathrm {d} }{\\mathrm {d} t}}\\iint _\\mathbb{S} \\mathbf {B} \\cdot \\mathrm {d} \\mathbf {s} =-{\\frac {\\mathrm {d} \\Phi _{\\mathbf {B} }}{\\mathrm{d} t}}$$ 表明电动势(V)是磁通量的变化引起 麦克斯韦-安培定律：磁场可以通过以下两种方法产生：一种是靠传导电流（原本的安培定律），另一种是靠时变电场，称位移电流（麦克斯韦修正项） $${\\displaystyle \\oint _{\\mathbb {L} }\\ \\mathbf {B} \\cdot \\mathrm {d} {\\boldsymbol {\\ell }=\\mu _{0}I+\\mu _{0}\\varepsilon _{0}{\\frac {\\mathrm{d} }{\\mathrm {d} t}} \\iint _\\mathbb{S} \\mathbf E \\cdot \\mathrm {d}s }=\\mu _{0}I+\\mu _{0}\\varepsilon _{0}{\\frac {\\mathrm{d} \\Phi _{\\mathbf {E} }}{\\mathrm {d} t}}}$$ $\\mu_0$是真空磁导率 表明磁场环量由电流和电场的变化引起 电磁波的传播通过一系列数学推导，可以得到真空中的波动方程：$$\\begin{aligned}% laplacian operator\\nabla ^{2} \\mathbf {E} -{\\frac {1}{c^{2}}}{\\frac {\\partial ^{2}\\mathbf {E} }{\\partial t^{2}}} &amp;=0\\\\nabla ^{2} \\mathbf {B} -{\\frac {1}{c^{2}}}{\\frac {\\partial ^{2}\\mathbf {B} }{\\partial t^{2}}} &amp;=0 \\end{aligned}$$称为双曲型偏微分方程， 其中 $c=\\frac{1}{\\sqrt{\\mu_0\\epsilon_0}}$是真空中的光速 $\\nabla^2$是拉普拉斯算子，在直角坐标系中是：$$\\nabla ^{2} =\\left({\\frac {\\partial ^{2}}{\\partial x^{2}}}+{\\frac {\\partial ^{2}}{\\partial y^{2}}}+{\\frac {\\partial ^{2}}{\\partial z^{2}}}\\right)$$波动方程描述了波在时空中传播的规律。对平面波，它的一个解是： $$\\begin{align}E = E_0 \\cos(\\omega t - kr + \\phi) \\H = H_0 \\cos(\\omega t - kr + \\phi)\\end{align}$$是和位置和时间有关的函数。 对比经典力学中的机械波方程一致：$$\\nabla ^{2} \\psi -{\\frac {1}{v^{2}}}{\\frac {\\partial ^{2}\\psi }{\\partial t^{2}}} =0$$其中，$\\psi$是波函数，v是波速 麦克斯韦方程组的局限因为麦克斯韦方程组完全不能表达光子的概念，任何涉及到单独光子的现象，例如光电效应、普朗克定律、单光子探测器、电磁场的量子纠缠等等，假若使用麦克斯韦方程组来解释，都会遇到困难。对于这些案例，必须用量子电动力学的理论来给予解释 FDTD(时域有限差分法)在实际中，电磁波的传播是一个非常复杂的问题，需要考虑介质、边界和干涉问题，不能简单用平面简谐波计算，需要用数值方法来求解，FDTD是一种数值求解电磁波传播的方法，它是一种时域方法，通过离散化空间和时间，将麦克斯韦方程组转化为差分方程，然后通过迭代求解。转换差分需要后两个方程就可以了，因为前两个方程是关于电场和磁场的分布，而后两个方程是关于电场和磁场的变化，是关于时间的。中心差分是一种常用的差分方法，它是用前后两个点的值的平均值来估计中间点的值。对于一维情况，中心差分的公式是：$$\\frac{\\partial f}{\\partial x} \\approx \\frac{f(x+\\Delta x) - f(x-\\Delta x)}{2\\Delta x}$$ 对时间和空间使用中心差分，可以得到麦克斯韦方程组的差分形式，简单起见，使用真空一维情况理解 可见，其中的每一项都可由它的前两项推导而来。E 是在全时间步上、全空间，B 是在半时间步，半空间上计算(为何这样设计？而不是反过来)。如下： 上述最简单的一维情况综合起来：$$\\frac {\\partial E_x}{\\partial y} = \\frac{\\partial B_z}{\\partial t}$$在空间和时间上求解:令$$y = j \\Delta y, t = n \\Delta t$$离散化空间和时间，可以得到： 整理可以得到磁场和电场的更新方程：$$B_z(j+\\frac{1}{2}, n+\\frac{1}{2}) = B_z(j+\\frac{1}{2}, n-\\frac{1}{2}) + \\frac{\\Delta t}{\\Delta y} (E_x(j+1, n) - E_x(j, n))$$$$E_x(j, n+1) = E_x(j, n) + \\frac{\\Delta t}{\\Delta y} (B_z(j+\\frac{1}{2}, n+\\frac{1}{2}) - B_z(j-\\frac{1}{2}, n+\\frac{1}{2}))$$ 可以写出 FDTD 的算法步骤： initial field E, B by ?? for n = 0, nmax for j = 0, jmax-1 update B end for j = 0, jmax update E end end","link":"/2024/10/25/fdtd/"},{"title":"Google Flutter 初体验","text":"最近想着做个app，自己有一点android开发经验，但是从来没做过ios开发，就想用跨平台的方式，一劳永逸。于是对比了不少跨平台的方案，iconic, xamarin, react native，最后本打算用react native，偶然发现flutter，google的产品，于是尝试了一下。 flutter现在的版本已经支持windows, mac, linux的开发。照着官网例子操作一遍，感觉对开发者还是比较友好。环境配置如同golang一样一如即往的简单，一个flutter doctor搞定所有，flutter run 打包并push到设备上运行，最爽的事情来了，之后对dart文件修改保存之后马上应用到设备（hot-reload）。当然这不是flutter最大的优点，效率和一致性的开发体验才是最吸引的人，因为最后代码会编译成native code, 几乎和原生一样快，而且ios和android真正做到同一份代码，同一种效果。这是react native做不到的，因为react native最后是对原生控件的封装，ios和android的差别很难抹平，flutter自己实现了渲染才能自由控制。不得不佩服google的技术和工程能力。虽然要学习dart语言，但是这种c系像java混合javascript的语言学习代价不算高。随着flutter的首个发布预览版(Release Preview 1)正式发布，相信flutter会越来越成熟可靠。准备入坑了","link":"/2018/06/24/flutterstart/"},{"title":"有趣的位运算","text":"编程中逻辑运算是再常见不过了，针对二进制的逻辑运算是位运算（bitwise-operations），使用位运算经常可以实现一些非常geek的操作。 取反（NOT）1变0，0变1 NOT 0111 = 1000 取反可以用于翻转，比如对于一个无符号的8位整数，表示范围是0-255 a = 100, 则~a = 155，也就是255-100=155 符号取反，正数变成负数，负数变成正数 a = 7, ~a+1 = -7 本来求补码符号位不参与，但是这里取反+1正数正好变成负数的补码表示 与（AND）两个都是1则取1，否则为0 0101 (decimal 5) AND 0011 (decimal 3) = 0001 (decimal 1) 按位与经常用作标志位或者掩码 因为二进制的最后一个为0是偶数，1为奇数，所以 if (0 == a &amp; 1) { //偶数 } ip地址掩码确定网络号255.255.255.0 &amp; 192.168.1.3 或（OR）只要有1则为1，否则为0 0001 (decimal 1) OR 0010 (decimal 2) = 0011 (decimal 3) 按位或可以用于组合标志位，比如提取分量后用来组合 异或 （XOR）相同则为0，不同则为1 0101 (decimal 5) XOR 0011 (decimal 3) = 0110 (decimal 6) 最经典就是不使用第三个变量来交换a,b的值 a = 5; b=3; a ^= b b = a ^ b a ^= b 一个无序数组有一个唯一的数，其它都是2个数，如何找出唯一的那个数？如[1,2,3,2,3]因为x ^ x = 0, x ^ 0 = x, x ^ y ^ z = x ^ (y ^ z),所以依次把每个数xor运算最后就可以得到唯一的一个数 移位 （SHIFT）左移一位表示乘 2，右移一个表示 除2 00010111 (decimal +23) LEFT-SHIFT = 00101110 (decimal +46) 10010111 (decimal −105) RIGHT-SHIFT = 11001011 (decimal −53) 可以用来进行2、4、8的整除 位运算应用例子1. 判断n是否是2的幂n &amp; (n-1) == 0 2. 高低字节交换对于一个无符号的16位数 unsigned short a = 12345; a = a &gt;&gt; 8 | (a &amp; 0x00FF) &lt;&lt; 8); //14640 3. 颠倒给定的 32 位无符号整数的二进制位00000010100101000001111010011100 =&gt; 00111001011110000010100101000000 123456789function reverseBits(n: number): number { let ret = 0 //对于有符号不能用n&gt;0判断 for(let i = 0; i &lt; 32 &amp;&amp; n != 0; i++) { ret |= (n &amp; 1) &lt;&lt; (31-i) n &gt;&gt;&gt;= 1 } return ret &gt;&gt;&gt; 0}; 4. 无符号整数中位数为1的个数 (汉明重量)12345678function hammingWeight(n: number): number { let ret = 0; while (n) { n &amp;= n - 1; ret++; } return ret;} n &amp; n-1 每次会把n的最后一位1变成0更有o(1)的算法可以体会位运算的强大 12345678function hammingWeight(n: number): number { n = n - ((n &gt;&gt;&gt; 1) &amp; 0x55555555); n = (n &amp; 0x33333333) + ((n &gt;&gt;&gt; 2) &amp; 0x33333333); n = (n + (n &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f; n = n + (n &gt;&gt;&gt; 8); n = n + (n &gt;&gt;&gt; 16); return n &amp; 0x3f; }","link":"/2022/12/18/bitwise-operations/"},{"title":"go语言学习笔记","text":"if 可以有多个;隔开的语句，if xxx; yyy {…}。 golang语句分隔符其实是;但是可以省略 golang 中函数名头大小写决定了函数在包外的可见性！ a := value 简短变量声明只能用 在函数内， 注意是 声明 go 中指针是不能改变的 编译器自动选择在栈上还是堆上分配空间，但是不由var还是new方式决定！ 注意go 中 := 和 多重赋值, 和作用域的坑 包导入：. “xx”, _ “xx”, f “xx” 在循环中调用函数或者goroutine方法，一定要采用显示的变量调用，不要再闭包函数里面调用循环的参数. 123456789101112for i:=0; i&lt;limit; i++ { go func() { DoSomething(i) }() //错误的做法 go func(i int){ DoSomething(i) }(i)//正确的做法}//go run -racevar msg = &quot;hello&quot;go func() { fmt.Println(msg)}msg = &quot;bye&quot;//bye var f float64 = 212fmt.Println((5 / 9) * (f - 32)) //0 !!!fmt.Println((f - 32) * 5 / 9) //100fmt.Println((f - 32) * (5 / 9)) //0 !!!常量是在编译时确定的！！ go 中常量还有无类型字面量，精度更高。在声明中，无类型会转换成相应类型 slice 包含了一个指向数组的指针，但并非严格引用类型，append操作可能返回不同的底层 而数组是值类型，a = […]{1,2,3}; b := a; a[1] = 42; a,b 不等 map == nil 时存入会异常. 允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic 在go语言中所有函数参数是值拷贝传入 switch 语句中的 case 代码块会默认带上 break，但可以使用 fallthrough 来强制执行下一个 case 代码块 组合是go中面向对象的核心 go中函数栈是可变栈，递归深度没有限制？ print, println 不像fmt.print那样可以打印结构体等复杂类型,并没有格式化功能？ 闭包中引用的局部变量是地址，而不是某一时刻的值。注意这个陷阱，这在其它语言中也存在 defer 语句是在函数返回后执行！所以可以在函数内观察到返回值。参数是在defer声明时候确定 可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反 即使发生panic， defer语句也会执行！ recover 只在defer函数中有用 语言中最小的封装单元是package, 可见性是以包为单位的 接口有个坑: 包含nil值的接口不是一个nil接口 ，一个接口中包含一个动态类型（一个具体的类型）和一个动态值两部分组成，接口可以和nil比较，这个nil表示一个空接口（不包含任何值的接口）。但是包含nil的接口不是空接口: var i1 *bytes.Buffer 和 var i2 io.Writer 都是nil但是不等 1234567891011121314151617181920 println(&quot;----------------------------------&quot;)var i1 io.Writerprintln(i1)println(i1 == nil)var i2 *bytes.Bufferprintln(i2)println(i2 == nil)i1 = i2println(i1)//注意这里是falseprintln(i1 == nil)---------------------------------- (0x0,0x0) true 0x0 true (0x53c260,0x0) false 接口赋值中，如果使用值，则所有实现的reciever都应是值类型，如果是指针，则没有这个限制，可以是值或者指针。 var a writer = ConcreteWriter{} vs var a *writer = &amp;ConcreteWriter{} 函数中可以安全的返回局部变量的地址。 ch &lt;-chan int: readonly channel, 只能读出; ch chan&lt;- int: sendonly channel，只能写入","link":"/2019/11/05/go-note/"},{"title":"地铁移动广告原理的个人理解分析","text":"坐地铁时在高速行驶的列车上看到稳定的广告觉得挺有意思，就思考了下实现的原理。我们都知道人眼有视觉暂留，当图像以24帧每秒显示时，看起来像一幅连续的画面。可以肯定的是这个地铁广告也是利用了这种视觉暂留效果。设想一幅广告画面就是按24帧每秒播放的画面，但是处于固定位置的广告箱肯定不是一直亮，不然列车运行后看起来就是糊的 那么广告箱应该是按某一频率闪烁。计算一下：假设地铁速度是80km/h，约v≈22m/s，假设某一时刻整个广告箱亮（这个显示时间应该远远短于1/24秒），1/24秒后要在同上位置点亮下一个广告箱，但是此时行进了只有22/24 ≈ 0.916米？也就是说广告长度最多只有0.9多米长？但是广告往往都是大于这个长度的，怎么办？想到一种可能的办法就是拼接，也就是内容依次移动。下一个广告箱在1/24秒后显示上一个广告箱的内容。我用unity做了一个模拟来还原这种情况，是可以实现。 但是这个太费材料了，30秒广告需要安装30*22/0.9≈733块广告牌,总广告箱长度就是30*22=660米. 有没有省材料的方法？小时候都见过这种电视机： 显像管采用逐行扫描的方式，一帧内扫描完整个屏幕形成一幅画面: 如果安装一根竖直的灯管，当列车行进时，不停变换灯管上的“像素”,也在一帧内完成一幅图的扫描，同样以1.8米广告长度，24的帧率可以计算一下：广告条在一帧内移动距离也为0.9米，所以条的间距为0.9米。这里还有个条宽和显示时间问题，假设条宽为x，移动自身宽度时间为x/22，假设条宽为0.2米，则这个时间为0.0091秒，而显示时间和上面的静态帧一样，也应该是非常快，不会超过这个宽x/22。拼接的原理和上面一样，但是控制要复杂一些。这样计算的灯带个数：(22*30 + 0.9) / 1.1 = 600, 材料长度为120米。","link":"/2018/06/02/metroads/"},{"title":"从数学的角度判断车头距障碍的距离","text":"在驾驶的过程中，我们总需要判断车头距离障碍物的距离，以确保安全驾驶。经常看到有文章从参照点的方式来估计距离。本文将从数学的角度，探讨如何通过简单的计算和测量，来估算车头与障碍物之间的距离。 基本原理在使用参照点法时，我们通常会选择车头的阻档视线的某个位置为参照点，如果坐姿高，一般是车头引擎盖的前端位置，如果坐姿低，是前档风玻璃的下端位置。然后通过观察障碍物与参照点之间的相对位置，来判断距离。 数学模型假设我们眼睛E到地面的高度为$H_e$，车头参照点R到地面的高度为$H_r$，E点到R点的水平距离为$D_{er}$，R在墙面上视线方向投影点O的高度为$H_o$，通过三角形的相似原理，我们就可以计算出车头R到障碍物O的水平距离$D_{ro}$。 上图可以转化成下图的模型： 根据图中两个橙色相似三角形的性质，可以得到以下关系：$$\\frac{H_e - H_r}{D_{er}} = \\frac{H_r - H_o}{D_{ro}}$$通过变形，我们可以得到车头R到障碍物O的距离$D_{ro}$:$$D_{ro} = D_{er} \\cdot \\frac{H_r - H_o}{H_e - H_r}$$ 假设我们有以下已知量： 眼睛E到地面的高度$H_e$ = 1.5m 车头参照点R到地面的高度$H_r$ = 1m 我们坐位眼睛到参考点的水平距离为$D_{er}$ = 2.5m 那么，当我们观察在视线方向上与障碍物的交点O的高度$H_o$时，我们可以计算出车头R到障碍物O的距离$D_{ro}$。 $H_o$ = 0m时，$D_{ro}$ = 2.5 * 1 / 0.5 = 5m，如文中所说，当眼睛刚好看到前车轮胎时，距离5m 当$H_o$ = 0.5m时，$D_{ro}$ = 2.5 * 0.5 / 0.5 = 2.5m 当$H_o$ = 0.7m时，$D_{ro}$ = 2.5 * 0.3 / 0.5 = 1.5m 当$H_o$ = 0.8m时，$D_{ro}$ = 2.5 * 0.2 / 0.5 = 1m 当$H_o$ = 0.9m时，$D_{ro}$ = 2.5 * 0.1 / 0.5 = 0.5m 但是这个距离是参考点距离墙面的距离，一般参考点都不是在车的最前方的车头位置，如果要计算车头前端到墙面的距离，还需要减去参考点R到车头前端的距离。这也是一个固定值$D_{rh}$。 $$D_{ro} = D_{er} \\cdot \\frac{H_r - H_o}{H_e - H_r} - D_{rh}$$ 这也为什么能解释，轿车坐姿低时，参考点在前档风玻璃下端位置，当我看到轮胎下缘时，感觉实际距离比5m更近。 实际应用在实际驾驶中，我们可以通过以下步骤来估算车头与障碍物的距离： 测量高度：测量眼睛E到地面的高度$H_e$，车头参照点R到地面的高度$H_r$，眼睛E到参考点R的水平距离$D_{er}$，以及参考点R到车头前端的距离$D_{rh}$。 观察障碍物：当驾驶时，观察障碍物O在视线方向上的投影点P的高度$H_o$。 计算距离：因为公式中，$\\frac {D_{er}}{H_e - H_r}$是一个常量K，我们可以预先计算好这个值，然后通过观察$H_o$，快速计算出车头到障碍物的距离$D_{ro}$。比如上面我的例子中，这个值是5。","link":"/2025/12/25/drive-sense-distance/"},{"title":"mysql建立索引时为什么要求区分度高？","text":"因为InnoDB支持事务，空间利用率高（使用聚簇索引），行级锁等特点，是mysql的默认存储引擎。在建立索引时，通常说索引列区分度高效果更好，其原理是什么？MySQL B+树索引是MySQL中最常用的索引类型，它是一种基于B+树数据结构的索引方式。B+树索引的优点在于它可以快速定位到需要查找的数据，同时还可以支持范围查询和排序等操作。B+树是在B树基础上的一种优化，非叶子节点上仅存储键值，不存储数据；而所有数据记录均存储在叶子节点上，并且数据是按照顺序排列的。 如果一列数据为性别，只有1-2个值时，查询时会不会走索引？索引树是什么样？ 为什么not in也通常会使用索引失效？ 区分度对索引有什么影响？有如下一张表： 在sex字段上建立了一个索引，当使用 12SELECT * FROM `people` WHERE sex = 1;# 查询时间1.837s explain 显示 确实走了索引扫描，但是速度比不使用索引慢 12SELECT * FROM `people` ignore index(idx_sex) WHERE sex = 1 ;# 查询时间 0.615s 不走索引更快对于仅有1、2的b+tree树如下，相同的结点会分布在不同的分支上， 查询时会走过不同的分支而不是单单一边的分支 对于区分度高的age字段，值范围在[0,100] 之前, 使用索引可以显著减少扫描的行数： not in 索引失效123456789101112EXPLAIN SELECT * FROM `people` WHERE age NOT IN (83);/* 1 SIMPLE people ALL idex_age 995605 84.01 Using where */EXPLAIN SELECT age FROM `people` WHERE age NOT IN (83);/* 1 SIMPLE people range idex_age idex_age 5 836434 100.00 Using where; Using index */EXPLAIN SELECT age FROM `people` WHERE age NOT IN (83, 37)/* 1 SIMPLE people index idex_age idex_age 5 995605 100.00 Using where; Using index*/ not in 并不是总是不能使用索引，当查询的字段得包含索引字段，可以使用到索引，type为range 或 index，并不高效，当in中只有一个值时，会被查询优化器优化","link":"/2023/02/10/mysql-index/"},{"title":"记一次重置mysql8密码的操作","text":"停止服务 1service mysqld stop or systemctl stop mysqld.service 启动服务，不检查授权表 1mysqld --skip-grant-tables --skip-networking &amp; 报错：sock 权限问题 1sudo chown -R mysql:mysql /var/lib/mysql/ 执行重置 12alter user 'root'@'localhost' IDENTIFIED BY '123456';create user 'root'@'localhost' identified by '123456'; 都失败Operation ALTER USER failed for ‘root‘@’localhost’Operation CREATE USER failed for ‘root‘@’localhost’ 先执行flush privileges 仍然失败，可能是因为用户已经被删除了，再删除一次drop user ‘root‘@’localhost’;create user ‘root‘@’localhost’ identified by ‘123456’;提示密码不符合规则 1234SHOW VARIABLES LIKE 'validate_password%';set global validate_password.policy=0;set global validate_password.length=6; flush 一下 1flush privileges 重启 1service mysqld restart","link":"/2020/12/12/mysql-reset-pass/"},{"title":"python3 新特性总结","text":"1. f-string 字符串插值传统字符串格式化是使用%， python2.6 后引入了format提供了更强大，灵活的控制。python3 开始提供了字符串插值的方法，更加方便，清晰。这种方式在其它语言中并不陌生。 12345a = &quot;Peeter&quot;b = 50s = &quot;{0} has {1:.2f} kg&quot;.format(a, b)s2 = f&quot;{a} has {b:.2f} kg&quot; 2. 类型提示(python3.5)在代码提示和可读性上很有帮助a. 变量定义 123x:int = 10y:str = 'hello'c:list = [] b. 函数定义 12345def add(x:int,y:int)-&gt;int: return x+yprint(add(10,12))print(add('hello','world')) # ”编译“不会出错 类型提示并不能在运行时做类型检查 3. 枚举提供了另一种定义常量的方法(python 3.4)Enum模块定义了四个枚举类，它们可被用来定义名称和值的不重复集合: Enum, IntEnum, Flag 和 IntFlag。 此外还定义了一个装饰器 unique() 和一个辅助类 auto 123456789from enum import Enum, autoclass Color(Enum): RED = auto() GREEN = auto() BLUE = auto()print(Color.Red) #Color.REDprint(repr(Color.RED)) # &lt;Color.RED: 1&gt;for c in Color: print(c) 4. Data class 装饰器 (python 3.7+)减少样板代码，熟悉java spring的一定对@Data注解不默生。装饰器会自动生成诸如__init__和__repr__这样的特殊方法 12345678910111213from dataclass import dataclass@dataclassclass Square: w: float h: float desc: str def area(self)-&gt;float: return w*hs = Square(5.2, 2, 'a square')print(s)print(s.area()) 5. 扩展的可迭代对象解包es6 中有解构这个特性，算是一个不完整的版本。使用*x表示余下的迭代对象 12345678910head, *body, tail = range(5)print(head, body, tail)# 0 [1, 2, 3] 4first, _, third, *_ = range(5)print(first, third)seq = range(5)first, rest = seq[0], seq[1:]first, *rest = seq 6. LRU 缓存 (python3.2)使用functools模块的lur_cache装饰器，可以缓存最多 maxsize 个此函数的调用结果，从而提高程序执行的效率，特别适合于耗时的函数。参数maxsize为最多缓存的次数，如果为None，则无限制。如果 typed=True，则不同参数类型的调用将分别缓存，例如 f(3) 和 f(3.0)。被 lru_cache 装饰的函数会有 cache_clear 和 cache_info 两个方法，分别用于清除缓存和查看缓存信息。 12345678910111213141516from functools import lru_cache@lru_cache(maxsize=6)def add(x, y): print(f&quot;calc {x} + {y}&quot;) return x + yprint(add(1, 2))print(add(1, 2)) # 第二次调用直接返回print(add(2, 3))print(add.cache_info())#CacheInfo(hits=1, misses=2, maxsize=6, currsize=1)add.cache_clear()print(type(add)) # &lt;class 'functools._lru_cache_wrapper'&gt; 7. pathlib (python3.4)可以更好操作路径了 1234import os.pathBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))TEMPLATES_DIR = os.path.join(BASE_DIR, 'templates') vs 1234from pathlib import PathBASE_DIR = Path(__file__).resolve().parent.parentTEMPLATES_DIR = BASE_DIR.joinpath('templates') 12345import osimport os.pathos.makedirs(os.path.join('src', '__pypackages__'), exist_ok=True)os.rename('.editorconfig', os.path.join('src', '.editorconfig')) vs 12345from pathlib import PathPath('src/__pypackages__').mkdir(parents=True, exist_ok=True)Path('.editorconfig').rename('src/.editorconfig')# 不必关心是/ 还是\\","link":"/2020/07/01/new-in-py3/"},{"title":"reactivex","text":"一个学习ReactiveX不错的地方：Intro to Rx以作记录： 概念 Observable 随时间发射item， 观察者（observer）可以注册到observable，以获得其事件，其实observable调用了observer的方法, 有 onNext, onError, onComplete Operators 逻辑操作observable， 返回一个新的observable Single 特殊的observable， 只有onSuccess, onError Subject ， 一种桥或者代理，即是observer又是observable Scheduler， operator通过调度器（Scheduler）来向observer发送通知。SubscribeOn 改变调度器，ObserverOn决定在哪个线程上发送通知 scheduler 决定action如何执行，如在线程池，新线程或者消息泵，当前线程上 调度执行action 调度执行observable上注册的observer 调度执行observable上发送来的通知 AsObservable 将对象转换成更简单的类型（IObservable），去除一些副作用 SubscribeOn: 用特定的scheduler指定后台代码（Subscribe的代码，即observer）执行的地方 ObserveOn：用特定的scheduler指定notification执行的地方","link":"/2018/02/01/reactivex/"},{"title":"正则表达式中的断言","text":"断言属于Group constructs，但是不匹配具体的东西，所以也被称为零宽断言。他们用来指定一个位置，为这个断言为真时才继续进行匹配。 捕获型匹配(…) 匹配括号中的内容(a|b) 匹配a或者b(?&lt;name&gt;…), 同上但是为分组取一个名字，当分组很多时为分组取一个名字很有用。注：在golang,python中为(?P&lt;name&gt;...)以上匹配都会占用匹配位置，并生成分组，正则表达式内可以通过\\1,\\2,\\3 or \\k&lt;name&gt; 来引用 1&quot;aabcab&quot;.match(/(a)\\1/) //[&quot;aa&quot;, &quot;a&quot;, index: 0, input: &quot;aabcab&quot;, groups: undefined] (?:…) 匹配…内容，和(…)一样。但是不捕获分组 1&quot;foobar&quot;.match(/foo(?:ab|bar)/) //[&quot;foobar&quot;, index: 0, input: &quot;foobar&quot;, groups: undefined] 断言 (?=…) 正向先行断言（positive lookahead） 当执行匹配时，当该断言表达式如果为真（positive)，则匹配断言前面（lookahead）的内容。 1234/foo(?=bar)/.exec(&quot;foobar&quot;)//[&quot;foo&quot;, index: 0, input: &quot;foobar&quot;, groups: undefined]/foo(?=bar)bar/.exec(&quot;foobar&quot;)//[&quot;foobar&quot;, index: 0, input: &quot;foobar&quot;, groups: undefined] (?&lt;=…) 正向后发断言（positive lookbehind） 和前一个相反，当该断言表达式如果为真（positive)，则匹配断言后边（lookbehind）的内容。注意断言表达式写在左边，从断言表达式往后看。 12345/(?&lt;=foo)bar/.exec(&quot;foobar&quot;)//[&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]/(?&lt;=foo)bar/.exec(&quot;foubar&quot;)//null (?!…) 负向先行断言 (negative lookahead) 当执行匹配时，当该断言表达式如果为假（negative），则匹配断言前面的内容。注意断言表达写在右边，即从断言表达式往前看。 12345/foo(?!bar)/.exec(&quot;foobar&quot;)//null/foo(?!bar)/.exec(&quot;foobaz&quot;)//[&quot;foo&quot;, index: 0, input: &quot;foobaz&quot;, groups: undefined] (?&lt;!…) 负向后发断言 (negative lookbehind) 当执行匹配时，当该断言表达式如果为假（negative）， 则匹配断言后面的内容。 12345/(?&lt;!foo)bar/.exec(&quot;foobar&quot;)//null/(?&lt;!foo)bar/.exec(&quot;farbar&quot;)//[&quot;bar&quot;, index: 3, input: &quot;farbar&quot;, groups: undefined]","link":"/2020/08/23/regex-assert/"},{"title":"numpy中轴的理解","text":"最近学numpy中的ndarray，许多函数如np.mean, np.sum, np.min等都有个axis的参数，那什么是轴呢？其实就是数组的维度，对应ndarray.ndim的值， 也即ndarray.shape的len. 一维数组有一条轴0， 二维数组有两条轴0，1， 三维数组有三条轴0，1，2，依次类推。这与空间的轴概念是对应的，轴代表了变化的方向, 比如一个二维数组： arr=[[1, 2, 3], [4, 5, 6]]使用arr[i][j]访问元素，i即为第0轴，j为第1轴，沿0轴变化的元素为：arr[0][j], arr[1][j], 沿1轴变化的元素为：arr[i][0], arr[i][1], arr[i][2]。 这些函数正是在这个方向上进行计算 In [39]: arr Out[39]: array([[1, 2, 3], [4, 5, 6]]) In [40]: arr.min(axis=0) Out[40]: array([1, 2, 3] In [41]: arr.sum(axis=0) Out[41]: array([5, 7, 9] In [42]: arr.min(axis=1) Out[42]: array([1, 4]) In [43]: arr.sum(axis=1) Out[43]: array([ 6, 15]) 二维数组中0轴按列计算，1轴按行计算，并且会降低一维。再看一个三维的例子： In [53]: arr Out[53]: array([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]], [[12, 13, 14], [15, 16, 17]]]) In [54]: arr.sum(axis=0) Out[54]: array([[18, 21, 24], [27, 30, 33]]) In [55]: arr.sum(axis=1) Out[55]: array([[ 3, 5, 7], [15, 17, 19], [27, 29, 31]]) In [56]: arr.sum(axis=2) Out[56]: array([[ 3, 12], [21, 30], [39, 48]]) axis=0即按arr[0][j][k], a[1][j][k], a[2][j][k]求值， 0 + 6 + 12， 1 + 7 + 13,axis=1同理arr[i][0][k], a[i][1][k]，注意第二维长度为2，即：0+3，1+4, 2+7axis=2求arr[i][j][0], arr[i][j][1], arr[i][j][2], 0+1+2, 3+4+5 转置也会有轴的概念，也和上面一致，np.transpose接受轴的参数，表示按轴的顺序重新reshape数组，arr.T属性为一种特殊的转置形式，完全倒过来，0，1，2变为2，1，0，看下面输出： In [79]: arr Out[79]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) In [80]: arr.shape Out[80]: (2, 3, 4) In [81]: arr.transpose(2, 1, 0) Out[81]: array([[[ 0, 12], [ 4, 16], [ 8, 20]], [[ 1, 13], [ 5, 17], [ 9, 21]], [[ 2, 14], [ 6, 18], [10, 22]], [[ 3, 15], [ 7, 19], [11, 23]]]) In [82]: arr.T Out[82]: array([[[ 0, 12], [ 4, 16], [ 8, 20]], [[ 1, 13], [ 5, 17], [ 9, 21]], [[ 2, 14], [ 6, 18], [10, 22]], [[ 3, 15], [ 7, 19], [11, 23]]]) shape由2，3，4变为4，3，2, arr[i][j][k]上的元素变换到arr[k][j][i]上： In [96]: arr Out[96]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) In [97]: arrT=arr.T In [98]: assert arr[0][1][2] == arrT[2][1][0], &quot;should equal&quot; np.swapaxes 可以指定交换两个轴，道理同上，比如将0，1轴交换： In [101]: arr Out[101]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) In [102]: arrS = arr.swapaxes(0, 1) In [103]: arrS.shape Out[103]: (3, 2, 4) In [104]: arrS Out[104]: array([[[ 0, 1, 2, 3], [12, 13, 14, 15]], [[ 4, 5, 6, 7], [16, 17, 18, 19]], [[ 8, 9, 10, 11], [20, 21, 22, 23]]])","link":"/2018/01/04/numpy-ndarray-axis/"},{"title":"python中的包和导入","text":"python使用包（package）、模块（module）来组织代码，以便于维护和管理。使用关键字import来导入模块。导入要指定搜索路径，即从何处搜索模块。Python搜索模块路径是由四部分构成的： 程序的主目录: 执行文件的目录，即__main__文件的目录。 PATHONPATH目录：环境变量，可以设置或扩展它。 标准目录：DLLS, Lib, site-packages目录。 .pth文件的目录: 可以放在python安装目录或site-packages中。每行一个路径最后这4部分的路径都存储在sys.path列表中。因此也可以在代码中使用sys.path.add(“/path/to/module”)来添加自定义搜索路径。 导入基础实验环境：python3.9.2 windows 12import PACKAGE OR MODULE [as ALIAS] from PACKAGE OR MODULE import [MODULE or OBJECT] [as ALIAS] 考虑如下的结构： 在main中import sub时打印打sub： 1&lt;module 'sub' (namespace)&gt; &lt;class 'module'&gt; 可见package也是一种module，只是标识为namespace了。 绝对导入和相对导入 绝对导入：当从sys.path路径去搜索模块时，称为绝对导入。比如，import sys，import os。执行sub_main.py，如果我们要导入上级目录的top.py，那么需要把top所在的目录添加到sys.path中。 1234567# sub_main.pyimport sysimport ossys.path.append(os.path.abspath(os.path.dirname(__file__) + '/..'))# sys.path.append('..') 依赖当前命令的执行目录，可以用os.getcwd()获取。print(sys.path)import top 绝对导入简单清晰明了。 相对导入形如： 1234from . import xfrom .. import xfrom .m import xfrom ...m import x 相对导入能避免一些包路径更改引入的大量绝对路径修改的麻烦。 相对导入有一个很重要的限制，就是相对路径不是一个顶层包，即__name__属性为__main__的顶层模块所在的目录 12# main.pyimport sub.sub2 main 导入sub2sub2.py 有如下导入情境： 12345678910111213141516171819# sub2.py## sub2 导入同包内的sub1# import sub1 # error: No module named 'sub1'import sub.sub1 # ok,绝对导入from . import sub1 # ok, 相对导入模块from .sub1 import add # ok, 相对导入模块内的函数print(add(1, 2))## 导入子包sub_subfrom .sub_sub import sub_sub # o, 相对导入## 导入上层的top# from .. import top # error: attempted relative import beyond top-level package# 但是如果把整个python-import作为一个包，由另外的模块来引用。这样..就不是一个顶层包，# from .. import top就是合法的import top # ok, 绝对导入print(&quot;module sub2&quot;) __init__.py当导入一个模块时（不管这个模块是包还是普通模块），包中的__init__.py文件会被自动导入。该文件可以用来做一些模块的初始化，控制import *的行为，简化外部导入，但有很多说法，只有目录下包含一个__init__.py文件才是一个包，我觉得是不对的。至少我自己使用中不是这样的。__init__.py只是一个会自动执行的普通py文件 考虑在main中导入sub_sub.py文件： 1234567891011121314151617181920212223242526272829303132333435# main.py# 当sub.__init__.py 中存在如下导入时：# from .sub_sub import sub_sub# from . import sub1# 只需要导入sub就可以使用sub_sub和sub1。# 否则，需要导入import sub.sub_sub.sub_sub和sub.sub1。import subprint(sub.sub1.os.getcwd())print(sub.sub_sub.sub(1, 2))# sub1.pyimport osprint(&quot;module sub1&quot;)def add(a, b): return a + b# sub.__init__.pyfrom .sub_sub import sub_subfrom . import sub1print(&quot;sub __init__.py&quot;)def div(a, b): return a / b# sub_sub/sub_sub.pyprint('sub_sub： ', __file__)def sub(a, b): return a - b import, importlibimport 关键字是__import__函数的语法糖，在动态导入中推荐使用importlib而不是直接使用__import__。 123import importliba = importlib.import_module('sub.sub1') # 绝对导入b = importlib.import_module('sub1', package='sub') # 相对导入","link":"/2022/03/06/python-import/"},{"title":"Flutter中的Redux","text":"flutter通过widget树的形式构建UI，不同的widget怎么去访问或者传递一个数据（状态），并且在这个状态改变后通知到其它Widget呢，官方简单demo中是通过构造函数的参数把数据或者修改数据函数传递给子widget，但是随着应用规模扩大，widget树会很复杂: 可以肯定的是，实际项目复杂度远远超过上图，所以构造函数传递不太现实，而且会让Widget容易耦合到一起。官方有一种方案，就是使用InheritedWidget, 这样所有子Widget都可以通过context访问到这个Widget。有没有更方便，更好管理点的？Reactive中有Redux，搜索了下，发现dart中也有redux的实现，flutter中也有基于这个Redux的flutter_redux, 添加了额外的组件，如StoreProvider，StoreBuilder，StoreConnector方便在flutter中使用，只是基于语言特性上实现的一些模式，没有其它神秘的地方，比如StoreProvider就是一个InheritedWidget。Redux有两个特性可以解决上面的问题： app唯一的Store存着所有的状态，不管在哪里都可以访问，并且一个地方更新状态后，别外一个地方也可以得到通知。 那这不就是一个增加了observer的单例，这个特性更重要：所有数据流是单向的, 状态是只读的： 用户行为（如用户点击） Redux 分发一个action Redux在reducer中更新store, 这个状态是新创建的。 store更新后自动刷新widget 可以看看这个例子 但是仍有些疑问： ?如果要在action之后从外部获取数据怎么办？所以Redux又引入了middleware访问外部api，时机在Action和Reducer之间。 ?为什么是只读的，如果是只读的，那状态如果更新？Redux是通过创建副本的方法。为什么要这样做？方便比较两次数据是否更新，flutter_redux有个标记：distinct可以开启这个功能。而且可以通过devtools去追踪状态历史记录，这点很强大。 ?问题又来了，如何创建副本才是简单的方式？这个似乎对dart来说没有一个简单的方式，看到的例子都是手工编码。google本身有个built_value库，使用自动代码生成的方式，但仍不如js有immutable.js那样方便。 实际使用中redux有个坑，就是当appstate改变时，所有StoreBuilder和StoreConnector都会重构，方法是不要使用StoreBuilder,并把StoreConnector的distinct设为true，实现ViewModel的==","link":"/2018/09/05/reduxinflutter/"},{"title":"UGUI中的anchor和canvas(屏幕适配)","text":"ugui的布局功能比css更为灵活，但相应也导致更多概念，但是如果能理解下边几个问题，有助于更好地使用ugui布局 Rect Transform上的锚点(anchor)和支点(pivot)，作用是什么？对自身位置有什么影响？ CanvasScaler原理？和anchor和pivot有关系没有？ LayoutElement如何影响Rect Transform？ RectTransform继承自Transform并添加了一些布局属性，最重要的就是anchor和pivot。Transform表示一个点，RectTransform表示一个矩形区域。值得注意的是Canvas节点也是一个RectTransform组件上挂了一个Canvas组件，它也是一个Rect另外需要知道的是，UGUI的屏幕坐标系左下角为（0，0），右上角为（1，1） Anchor内部表示为2个点： 12public Vector2 anchorMin { get; set; }public Vector2 anchorMax { get; set; } 是在父矩形的坐标，0-1之间，即父矩形的左下角、右上角，构成了一个矩形区域，用来表示自身在父组件的定位。因为一个矩形可以理解成四条边、四个顶点，所以会有不同的理解。根据anchor中x,y不同，RectTransform组件会展现不同的属性： 当anchor中anchorMin.x != anchorMax.x时，x横向位置和组件宽由left，right决定，当相等时，表示为posX和width 当anchor中anchorMin.y != anchorMax.y时，y纵向位置和组件高由top，bottom决定，当相等时，表示为posY和height 这会让人有些费解： pos X, pos Y为pivot点与anchor点在父坐标系中的差值，width，height为自身Rect的大小，当父Rect大小变化时，自身的大小和相对位置不会变，不会自适应 当为left，right, top，bottom时是自身Rect的四边与anchor在父坐标系的距离，由于这四个相对距离不会变化，当父Rect大小变化时，子Rect的width，height就会跟着变化以维持不变的相对距离 PivotPivot即上图中空心圆环的位置，是在自身Rect中规一化的坐标。表示的是在自己坐标系中的的位置它是旋转和缩放的中心点，同时也是Rect定位到父级时pos X, pos Y的定位点（当anchorMin, anchorMax重合时） RectTransform组件的蓝图和原始编辑模式蓝图模式按下之后忽略RectTransform上的旋转和缩放，看下图就明白了，只是用于方便编辑 原始编辑模式(Raw Edit Mode)默认情况下，调整Pivot和Anchor会维持当前Rect的位置和大小，当按下Raw Edit Mode时，Rect的大小和位置会随着调整变化 CanvasScaler会随着Canvas组件Render Mode会有不同情况： World Space ui会通过Canvas上指定的相机绘制，通常用于3d ui，这时CanvasScaler组件 UI Scale Mode变为 World 且不可更改。Canvas组件上的位置、大小都可以自行调节。此时ui组件的单位为Unity单位，可视范围受相机的可视范围影响 当为 Screen Space - Overlay 和 Screen Space - Camera 时，ui都在屏幕空间绘制，ui一定遮挡场景的物体。这时的Canvas组件时，它的大小是不能人为调整的，受CanvasScaler组件控制，UI Scale Mode会有三个选项 UI Scale ModeCanvas组件的scale * width和height为屏幕的像素宽高，scale表示将canvas中的元素缩放scale值 Constant Pixel Size: Canvas中的ui 大小不会随屏幕改变，保持固定大小的像素值。但因为不同设备有不同的分辨率，ui 在屏幕在就会显示过大或者过小（占据了不同的比例） Constant Physical Size: 与Constant Pixel Size类似，不过通过指定一个物理单位（cm, mm, inch, points等），ui元素的width，height是按这个单位计算，实际的像素会乘以不同设备的DPI比如在1920x1080分辨率，dpi为96的设备上，屏幕为宽：1920 / 96 = 20inch， 高1080 / 96 = 11.25inch，当设置image with=10，2个即会占满整个屏幕： Scale With Screen Size: 响应式ui会用这个，会随着屏幕缩放，ui元素占据屏幕的比例是不变的。这时会出现一个参照分辨率的选项（Reference Resolution），也叫设计分辨率，因为在做ui设计时会按照一个固定的分辨率设计ui。比如设置参照分辨率为1920x1080时，摆放的ui在4k屏幕上（3840x2160）看不出有什么不同，因为Canvas的scale会设置成2 ，即当屏幕大于设计分辨率时，scale大小1，反之小于1。这时根据 Screen Match Mode scale又有不同的计算策略： Expand，增大Canvas的size保证UI都能显示 1scaleFactor = Mathf.Min(screenSize.x / referenceresolution.x, screenSize.y / referenceresolution.y); 假设referenceresolution = (800,600), screenSize=(1920,1080) screenSize.x / referenceresolution.x = 2.4screenSize.y / referenceresolution.y = 1.8所以scale=1.8 当screenSize 大于 referenceresolution时会尽可小的放大Canvas上的元素，保证在屏幕内当screenSize 小于 referenceresolution时，会尽可能地缩小Canvas上的UI元素，保证在屏幕内 因为canvasSize = screenSize / min(scale)，所以Canvas的Size总是大于referenceresolution Shrink，缩小Canvas可能会裁剪掉UI，但是不会出色空白这种情况和 Expand相反 1scaleFactor = Mathf.Max(screenSize.x / referenceresolution.x, screenSize.y / referenceresolution.y); 上例中的scale=2.4，canvas的size就会小于referenceresolution Match Width Or Height 12345const float kLogBase = 2;float logWidth = Mathf.Log(screenSize.x / m_ReferenceResolution.x, kLogBase);float logHeight = Mathf.Log(screenSize.y / m_ReferenceResolution.y, kLogBase);float logWeightedAverage = Mathf.Lerp(logWidth, logHeight, m_MatchWidthOrHeight);scaleFactor = Mathf.Pow(kLogBase, logWeightedAverage); 在上例子中：当m_MatchWidthOrHeight=0，以width为参照，即scale=2.4; 这时x方向的分辨率变化UI都能完全显示，但y方向可能会被裁剪当m_MatchWidthOrHeight=1，以height为参照，即scale=1.8；这时y方向的分辨率变化UI都能完全显示，但x方向可能会被裁剪 在2.4-1.8之间并不是线性的，因为这样的效果更好： // We take the log of the relative width and height before taking the average.// Then we transform it back in the original space.// the reason to transform in and out of logarithmic space is to have better behavior.// If one axis has twice resolution and the other has half, it should even out if widthOrHeight value is at 0.5.// In normal space the average would be (0.5 + 2) / 2 = 1.25// In logarithmic space the average is (-1 + 1) / 2 = 0 anchor和pivot会作用于CanvasScaler，当Canvas变化时，会因anchor和pivot不同有影响没有？准确说没有直接关系，父rect的变化（包括Canvas）会因为anchor原因影响子rect的大小 Reference Pixels Per Unit 作用sprite 有一个属性，Pixels Per Unit 表示每unity单位占多少像素，默认是100，当修改为50时，相同的图片占的unity单位*2，所以变大了 Reference Pixels Per Unit 是用于将像素转换到UI的单位时计算ui的content size。当导入的sprite size为100， Pixels Per Unit 为100，Reference Pixels Per Unit 为 100，则把这个图片放到ui上的size为 100 * (Reference Pixels Per Unit / Pixels Per Unit) = 100。当_Reference Pixels Per Unit_ 为200时，同样的图片在ui中的size = 200 RectTransform进阶理解RectTransform中的属性很有帮助，可以在编程中修改： RectTransform.position 是unity的世界坐标系中的位置，即使不是Screen Space绘制在世界中也有一个坐标 RectTransform.localPosition 是pivot点在父元素坐标系中的位置（父元素的pivot），是有z值的。当父子元素pivot相同时，此时localPostion的值和anchoredPositon相等 RectTransform.anchoredPosition 无z值，是pivot相对于anchor的坐标（anchor重合），往右为正，往上为正。可以理解成锚定后的相对偏移量 RectTransform.sizeDelta 并不能直接获取到Rect的长宽（除非它的anchor点重合），因为sizeDelta真正含义是RECT的大小比anchor的矩形大小差值 即图中红色两段相加为sizeDelta.x, 蓝色两段相加为sizeDelta.y，因为ui比anchor矩形小，所以为负。sizeDelta = （-63，-89）内部 123456sizeDelta = offsetMax - offsetMin``` 而```c#offsetMax = ui矩形右上角坐标 - 锚点矩形右上角坐标offsetMin = ui矩形左下角坐标 - 锚点矩形左下角坐标 当需要获取ui大小时，可以使用rect.size而不是sizeDelta。但是rect.size是只读的，如果要设置大小的话最方便的是使用RectTransform.SetSizeWithCurrentAnchors函数 下边是计算代码和关系 1234567891011121314151617181920RectTransform rect = GetComponent&lt;RectTransform&gt;();RectTransform parentRect = transform.parent.GetComponent&lt;RectTransform&gt;();Vector2 GetAnchoredPositionByLocalPosition(){ Vector2 localPosition2D = new Vector2(rect.localPosition.x, rect.localPosition.y); Vector2 anchorMinPos = parentRect.rect.min + Vector2.Scale(rect.anchorMin, parentRect.rect.size); Vector2 rectMinPos = rect.rect.min + localPosition2D; Vector2 offsetMin = rectMinPos - anchorMinPos; Vector2 anchorMaxPos = parentRect.rect.max - Vector2.Scale(Vector2.one - rect.anchorMax, parentRect.rect.size); Vector2 rectMaxPos = rect.rect.max + localPosition2D; Vector2 offsetMax = rectMaxPos - anchorMaxPos; Vector2 sizeDelta = offsetMax - offsetMin; Vector2 anchoredPosition = offsetMin + Vector2.Scale(sizeDelta, rect.pivot); return anchoredPosition;} LayoutElementRectTransform能实现往往依赖父元素的进行布局。但是有些情况父元素又需要子元素来进行布局，或者说容器大小在具体元素内容确定前是无法提前预知的，是动态变化的。这时会用到ILayoutElement，它会根据LayoutConroller有不同的行为，间接影响RectTransform。很多组件都实现了ILayoutElemnt接口，比如Image，Text，LayoutGroup，LayoutElement可以去覆盖这些默认行为。简单说和anchor、pivot之类并没有直接关系，是两套系统，可以单独去理解，并不详细说明了","link":"/2023/01/17/ugui-anchor-and-canvas/"}],"tags":[{"name":"其它","slug":"其它","link":"/tags/%E5%85%B6%E5%AE%83/"},{"name":"bit","slug":"bit","link":"/tags/bit/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"Shader","slug":"Shader","link":"/tags/Shader/"},{"name":"exception","slug":"exception","link":"/tags/exception/"},{"name":"encoding","slug":"encoding","link":"/tags/encoding/"},{"name":"utf8","slug":"utf8","link":"/tags/utf8/"},{"name":"fdtd","slug":"fdtd","link":"/tags/fdtd/"},{"name":"电磁场","slug":"电磁场","link":"/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"dart","slug":"dart","link":"/tags/dart/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"bitwise-op","slug":"bitwise-op","link":"/tags/bitwise-op/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"unity","slug":"unity","link":"/tags/unity/"},{"name":"车距感知","slug":"车距感知","link":"/tags/%E8%BD%A6%E8%B7%9D%E6%84%9F%E7%9F%A5/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"db","slug":"db","link":"/tags/db/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"reactivex","slug":"reactivex","link":"/tags/reactivex/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"断言","slug":"断言","link":"/tags/%E6%96%AD%E8%A8%80/"},{"name":"环视","slug":"环视","link":"/tags/%E7%8E%AF%E8%A7%86/"},{"name":"数据分析","slug":"数据分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"categories":[{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"图形学","slug":"图形学","link":"/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"其它","slug":"其它","link":"/categories/%E5%85%B6%E5%AE%83/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"computer","slug":"computer","link":"/categories/computer/"}],"pages":[{"title":"","text":"","link":"/404.html"},{"title":"关于我","text":"有人说你变了，却没人问你经历了什么；有人说你还是老样子，却不知道初心难守。想想定义了我现在的生活的所有东西，你爱的人，你的工作，你的同事，你的家人，你的朋友，就这样接受现在的样子，还是不顾一切的改变，去创造新的可能？","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}